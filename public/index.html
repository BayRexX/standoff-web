<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="UTF-8">
<title>FPS Multiplayer Shooter</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<style>
* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
    -webkit-touch-callout: none;
    -webkit-user-select: none;
    user-select: none;
    -webkit-tap-highlight-color: transparent;
}

body {
    overflow: hidden;
    background: #000;
    font-family: 'Arial', sans-serif;
    touch-action: none;
    position: fixed;
    width: 100%;
    height: 100%;
}

#gameCanvas {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    z-index: 1;
}

/* –î–∂–æ–π—Å—Ç–∏–∫ –¥–≤–∏–∂–µ–Ω–∏—è */
#moveJoystick {
    position: fixed;
    left: 20px;
    bottom: 100px;
    width: 140px;
    height: 140px;
    border-radius: 50%;
    background: rgba(255, 255, 255, 0.1);
    backdrop-filter: blur(10px);
    border: 2px solid rgba(255, 255, 255, 0.2);
    z-index: 100;
    touch-action: none;
}

#moveJoystickInner {
    position: absolute;
    left: 40px;
    top: 40px;
    width: 60px;
    height: 60px;
    border-radius: 50%;
    background: rgba(255, 255, 255, 0.8);
    box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
    transition: transform 0.1s;
}

/* –ö–Ω–æ–ø–∫–∞ –ø—Ä—ã–∂–∫–∞ */
#jumpBtn {
    position: fixed;
    left: 40px;
    bottom: 30px;
    width: 80px;
    height: 80px;
    border-radius: 50%;
    background: radial-gradient(circle at 30% 30%, #4CAF50, #2E7D32);
    color: white;
    border: none;
    font-size: 28px;
    box-shadow: 0 4px 15px rgba(76, 175, 80, 0.4);
    z-index: 100;
    touch-action: none;
    display: flex;
    align-items: center;
    justify-content: center;
}

/* –ö–Ω–æ–ø–∫–∞ —Å—Ç—Ä–µ–ª—å–±—ã */
#shootBtn {
    position: fixed;
    right: 25px;
    bottom: 25px;
    width: 90px;
    height: 90px;
    border-radius: 50%;
    background: radial-gradient(circle at 30% 30%, #ff4444, #cc0000);
    color: white;
    border: none;
    font-size: 32px;
    box-shadow: 0 6px 20px rgba(255, 0, 0, 0.4);
    z-index: 100;
    touch-action: none;
    display: flex;
    align-items: center;
    justify-content: center;
}

/* –ú–∞–ª–µ–Ω—å–∫–∞—è –∫–Ω–æ–ø–∫–∞ —á–∞—Ç–∞ */
#chatBtn {
    position: fixed;
    right: 25px;
    top: 25px;
    width: 50px;
    height: 50px;
    border-radius: 50%;
    background: rgba(33, 150, 243, 0.8);
    color: white;
    border: none;
    font-size: 20px;
    box-shadow: 0 3px 10px rgba(33, 150, 243, 0.3);
    z-index: 100;
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
}

/* –û–∫–Ω–æ —á–∞—Ç–∞ */
#chatWindow {
    position: fixed;
    right: 85px;
    top: 25px;
    width: 300px;
    height: 400px;
    background: rgba(0, 0, 0, 0.85);
    backdrop-filter: blur(10px);
    border-radius: 15px;
    border: 1px solid rgba(255, 255, 255, 0.1);
    z-index: 1000;
    display: none;
    flex-direction: column;
    padding: 15px;
    box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
}

#chatMessages {
    flex: 1;
    overflow-y: auto;
    margin-bottom: 10px;
    color: white;
    font-size: 14px;
    line-height: 1.4;
}

#chatMessages div {
    margin-bottom: 8px;
    padding: 5px 10px;
    background: rgba(255, 255, 255, 0.1);
    border-radius: 8px;
    word-wrap: break-word;
}

#chatMessages .system {
    color: #4CAF50;
    font-style: italic;
    text-align: center;
}

#chatMessages .kill {
    color: #ff4444;
    font-weight: bold;
}

#chatInput {
    width: 100%;
    padding: 10px 15px;
    border: 1px solid rgba(255, 255, 255, 0.2);
    border-radius: 8px;
    background: rgba(255, 255, 255, 0.1);
    color: white;
    font-size: 14px;
    outline: none;
}

#chatInput::placeholder {
    color: rgba(255, 255, 255, 0.5);
}

/* –ü—Ä–∏—Ü–µ–ª */
#crosshair {
    position: fixed;
    left: 50%;
    top: 50%;
    transform: translate(-50%, -50%);
    width: 24px;
    height: 24px;
    pointer-events: none;
    z-index: 99;
}

#crosshair::before,
#crosshair::after {
    content: '';
    position: absolute;
    background: rgba(255, 255, 255, 0.9);
    box-shadow: 0 0 4px rgba(0, 0, 0, 0.8);
}

#crosshair::before {
    width: 24px;
    height: 4px;
    top: 10px;
    left: 0;
    border-radius: 2px;
}

#crosshair::after {
    width: 4px;
    height: 24px;
    left: 10px;
    top: 0;
    border-radius: 2px;
}

/* –ò–Ω—Ç–µ—Ä—Ñ–µ–π—Å */
#ui {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    padding: 15px;
    background: linear-gradient(to bottom, rgba(0,0,0,0.8), transparent);
    color: white;
    z-index: 100;
    display: flex;
    justify-content: space-between;
    font-size: 16px;
    font-weight: bold;
    text-shadow: 1px 1px 2px black;
}

.health-bar {
    width: 150px;
    height: 20px;
    background: rgba(0, 0, 0, 0.5);
    border: 2px solid #333;
    border-radius: 10px;
    overflow: hidden;
}

#healthFill {
    height: 100%;
    background: linear-gradient(to right, #ff0000, #00ff00);
    width: 100%;
    transition: width 0.3s;
}

/* –ú–µ–Ω—é */
#menu {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0, 0, 0, 0.95);
    z-index: 1000;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    color: white;
    text-align: center;
}

.menu-content {
    max-width: 500px;
    padding: 30px;
    background: rgba(40, 40, 40, 0.9);
    border-radius: 15px;
    box-shadow: 0 10px 40px rgba(0, 100, 255, 0.3);
}

.menu-content h1 {
    color: #4CAF50;
    margin-bottom: 20px;
    font-size: 2.5em;
    text-shadow: 0 0 10px rgba(76, 175, 80, 0.5);
}

.btn {
    background: linear-gradient(to bottom, #2196F3, #1976D2);
    color: white;
    border: none;
    padding: 15px 30px;
    margin: 10px;
    border-radius: 8px;
    font-size: 18px;
    font-weight: bold;
    cursor: pointer;
    transition: all 0.3s;
    min-width: 200px;
    box-shadow: 0 4px 15px rgba(33, 150, 243, 0.3);
}

.btn:hover {
    background: linear-gradient(to bottom, #1976D2, #0D47A1);
    transform: translateY(-2px);
    box-shadow: 0 6px 20px rgba(33, 150, 243, 0.4);
}

.btn-success {
    background: linear-gradient(to bottom, #4CAF50, #388E3C);
    box-shadow: 0 4px 15px rgba(76, 175, 80, 0.3);
}

.btn-success:hover {
    background: linear-gradient(to bottom, #388E3C, #2E7D32);
    box-shadow: 0 6px 20px rgba(76, 175, 80, 0.4);
}

.controls-info {
    background: rgba(255, 255, 255, 0.1);
    padding: 15px;
    border-radius: 10px;
    margin: 15px 0;
    text-align: left;
}

.controls-info h3 {
    color: #2196F3;
    margin-bottom: 10px;
}

.controls-info ul {
    list-style: none;
    padding-left: 10px;
}

.controls-info li {
    margin: 8px 0;
    color: #ddd;
}

.hidden {
    display: none !important;
}

/* –£–≤–µ–¥–æ–º–ª–µ–Ω–∏—è */
#notification {
    position: fixed;
    bottom: 20px;
    left: 50%;
    transform: translateX(-50%);
    background: rgba(0, 0, 0, 0.8);
    color: white;
    padding: 15px 30px;
    border-radius: 10px;
    z-index: 1000;
    text-align: center;
    animation: slideUp 0.3s;
}

@keyframes slideUp {
    from { transform: translate(-50%, 100px); opacity: 0; }
    to { transform: translate(-50%, 0); opacity: 1; }
}

/* –≠—Ñ—Ñ–µ–∫—Ç –ø–æ–ø–∞–¥–∞–Ω–∏—è */
.hit-effect {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    pointer-events: none;
    z-index: 1000;
    animation: hitFlash 0.2s;
}

@keyframes hitFlash {
    0% { background: rgba(255, 0, 0, 0.3); }
    100% { background: transparent; }
}

/* –ü—É–ª–∏ */
.bullet-hole {
    position: absolute;
    width: 6px;
    height: 6px;
    background: #ff0;
    border-radius: 50%;
    box-shadow: 0 0 10px #ff0;
    pointer-events: none;
    z-index: 50;
    animation: bulletFade 2s forwards;
}

@keyframes bulletFade {
    0% { opacity: 1; }
    100% { opacity: 0; }
}

/* –†–µ–∂–∏–º –ü–ö */
.pc-controls {
    position: fixed;
    bottom: 20px;
    left: 50%;
    transform: translateX(-50%);
    background: rgba(0, 0, 0, 0.7);
    padding: 10px 20px;
    border-radius: 10px;
    color: white;
    font-size: 12px;
    z-index: 99;
    display: none;
}
</style>
</head>
<body>

<!-- –ú–µ–Ω—é -->
<div id="menu">
    <div class="menu-content">
        <h1>üéØ FPS Multiplayer Shooter</h1>
        <p style="margin-bottom: 20px; color: #ccc;">–ü–æ–¥–∫–ª—é—á–µ–Ω–∏–µ –∫ –≤–∞—à–µ–º—É —Å–µ—Ä–≤–µ—Ä—É</p>
        
        <div class="controls-info">
            <h3>üì± –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –Ω–∞ —Ç–µ–ª–µ—Ñ–æ–Ω–µ:</h3>
            <ul>
                <li>‚Ä¢ –õ–µ–≤–∞—è —á–∞—Å—Ç—å —ç–∫—Ä–∞–Ω–∞ - –¥–∂–æ–π—Å—Ç–∏–∫ –¥–ª—è –¥–≤–∏–∂–µ–Ω–∏—è</li>
                <li>‚Ä¢ –ü—Ä–∞–≤–∞—è —á–∞—Å—Ç—å —ç–∫—Ä–∞–Ω–∞ - –ø–æ–≤–æ—Ä–æ—Ç –∫–∞–º–µ—Ä—ã</li>
                <li>‚Ä¢ –ó–µ–ª–µ–Ω–∞—è –∫–Ω–æ–ø–∫–∞ (‚Üì) - –ø—Ä—ã–∂–æ–∫</li>
                <li>‚Ä¢ –ö—Ä–∞—Å–Ω–∞—è –∫–Ω–æ–ø–∫–∞ (üî´) - —Å—Ç—Ä–µ–ª—å–±–∞</li>
                <li>‚Ä¢ –°–∏–Ω—è—è –∫–Ω–æ–ø–∫–∞ (üí¨) - —á–∞—Ç</li>
            </ul>
        </div>
        
        <div class="controls-info">
            <h3>üñ•Ô∏è –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –Ω–∞ –ü–ö:</h3>
            <ul>
                <li>‚Ä¢ WASD - –¥–≤–∏–∂–µ–Ω–∏–µ</li>
                <li>‚Ä¢ SPACE - –ø—Ä—ã–∂–æ–∫</li>
                <li>‚Ä¢ –ú—ã—à—å - –ø–æ–≤–æ—Ä–æ—Ç –∫–∞–º–µ—Ä—ã</li>
                <li>‚Ä¢ –õ–ö–ú - —Å—Ç—Ä–µ–ª—å–±–∞</li>
                <li>‚Ä¢ Enter - –æ—Ç–∫—Ä—ã—Ç—å —á–∞—Ç</li>
                <li>‚Ä¢ ESC - —Å–∫—Ä—ã—Ç—å/–ø–æ–∫–∞–∑–∞—Ç—å –∫—É—Ä—Å–æ—Ä</li>
            </ul>
        </div>
        
        <button class="btn btn-success" onclick="startGame()">üéÆ –ù–ê–ß–ê–¢–¨ –ò–ì–†–£</button>
        <p style="margin-top: 20px; color: #aaa; font-size: 14px;">
            –°–µ—Ä–≤–µ—Ä: wss://fps-game-server-raki.onrender.com
        </p>
    </div>
</div>

<!-- –ò–≥—Ä–æ–≤–æ–π –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å -->
<div id="ui" class="hidden">
    <div>
        <span>‚ù§Ô∏è –ó–¥–æ—Ä–æ–≤—å–µ: <span id="healthText">100</span></span>
        <div class="health-bar">
            <div id="healthFill"></div>
        </div>
    </div>
    <div>
        <span>üë• –ò–≥—Ä–æ–∫–æ–≤: <span id="playersText">1</span></span>
        <br>
        <span>üéØ –£–±–∏–π—Å—Ç–≤: <span id="killsText">0</span></span>
        <span style="margin-left: 20px;">üíÄ –°–º–µ—Ä—Ç–µ–π: <span id="deathsText">0</span></span>
    </div>
</div>

<!-- –ß–∞—Ç -->
<button id="chatBtn" class="hidden" onclick="toggleChat()">üí¨</button>
<div id="chatWindow">
    <div id="chatMessages">
        <div class="system">–ß–∞—Ç –∏–≥—Ä—ã. –ù–∞–ø–∏—à–∏—Ç–µ —Å–æ–æ–±—â–µ–Ω–∏–µ –Ω–∏–∂–µ</div>
    </div>
    <input type="text" id="chatInput" placeholder="–°–æ–æ–±—â–µ–Ω–∏–µ (–¥–æ 100 —Å–∏–º–≤–æ–ª–æ–≤)" maxlength="100" onkeypress="handleChatKeyPress(event)">
</div>

<!-- –û—Å—Ç–∞–ª—å–Ω—ã–µ —ç–ª–µ–º–µ–Ω—Ç—ã -->
<div id="crosshair" class="hidden"></div>
<div id="moveJoystick" class="hidden">
    <div id="moveJoystickInner"></div>
</div>
<button id="jumpBtn" class="hidden" title="–ü—Ä—ã–∂–æ–∫">‚Üì</button>
<button id="shootBtn" class="hidden">üî´</button>
<div class="pc-controls" id="pcControls">–£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ: WASD - –¥–≤–∏–∂–µ–Ω–∏–µ, SPACE - –ø—Ä—ã–∂–æ–∫, –õ–ö–ú - —Å—Ç—Ä–µ–ª—å–±–∞</div>
<canvas id="gameCanvas"></canvas>
<div id="notification" class="hidden"></div>

<script src="https://cdn.jsdelivr.net/npm/three@0.155/build/three.min.js"></script>
<script>
/* ================= –ö–û–ù–§–ò–ì–£–†–ê–¶–ò–Ø ================= */
const CONFIG = {
    MOVE_SPEED: 0.15,
    ROTATION_SPEED: 0.002,
    PLAYER_HEIGHT: 1.7,
    PLAYER_RADIUS: 0.4,
    SHOOT_COOLDOWN: 300,
    MAX_HEALTH: 100,
    GRAVITY: 0.03,
    JUMP_FORCE: 0.25,
    SERVER_URL: 'wss://fps-game-server-raki.onrender.com'
};

/* ================= –ì–õ–û–ë–ê–õ–¨–ù–´–ï –ü–ï–†–ï–ú–ï–ù–ù–´–ï ================= */
let scene, camera, renderer;
let player, otherPlayers = new Map();
let walls = [];
let socket = null;
let gameStarted = false;
let isPC = false;

// –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ
let moveX = 0, moveY = 0;
let moveForward = false, moveBackward = false, moveLeft = false, moveRight = false;
let isJumping = false;
let velocityY = 0;
let isGrounded = true;
let mouseSensitivity = 0.002;

// –î–ª—è –º–æ–±–∏–ª—å–Ω–æ–≥–æ —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è
let isRotating = false;
let lastTouchX = 0, lastTouchY = 0;
let touchId = null;
let isShooting = false;
let lastShootTime = 0;

// –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞
let kills = 0;
let deaths = 0;

// –ß–∞—Ç
let chatVisible = false;
const chatMessages = [];

// –ü—É–ª–∏
const bullets = [];

/* ================= –û–ü–†–ï–î–ï–õ–ï–ù–ò–ï –ü–õ–ê–¢–§–û–†–ú–´ ================= */
function detectPlatform() {
    isPC = !('ontouchstart' in window) || window.innerWidth > 768;
    
    if (isPC) {
        document.getElementById('moveJoystick').classList.add('hidden');
        document.getElementById('jumpBtn').classList.add('hidden');
        document.getElementById('shootBtn').classList.add('hidden');
        document.getElementById('pcControls').style.display = 'block';
        
        // –ë–ª–æ–∫–∏—Ä—É–µ–º –∫–æ–Ω—Ç–µ–∫—Å—Ç–Ω–æ–µ –º–µ–Ω—é
        document.addEventListener('contextmenu', e => e.preventDefault());
        
        // –°–∫—Ä—ã–≤–∞–µ–º –∫—É—Ä—Å–æ—Ä –ø—Ä–∏ –∫–ª–∏–∫–µ –Ω–∞ –∫–∞–Ω–≤–∞—Å
        const canvas = document.getElementById('gameCanvas');
        canvas.addEventListener('click', () => {
            canvas.requestPointerLock = canvas.requestPointerLock || canvas.mozRequestPointerLock;
            canvas.requestPointerLock();
        });
        
        document.addEventListener('pointerlockchange', lockChange, false);
        document.addEventListener('mozpointerlockchange', lockChange, false);
        
        function lockChange() {
            if (document.pointerLockElement === canvas ||
                document.mozPointerLockElement === canvas) {
                document.addEventListener('mousemove', handleMouseMove, false);
            } else {
                document.removeEventListener('mousemove', handleMouseMove, false);
            }
        }
    } else {
        document.getElementById('moveJoystick').classList.remove('hidden');
        document.getElementById('jumpBtn').classList.remove('hidden');
        document.getElementById('shootBtn').classList.remove('hidden');
        document.getElementById('pcControls').style.display = 'none';
    }
}

/* ================= –£–ü–†–ê–í–õ–ï–ù–ò–ï –î–õ–Ø –ü–ö ================= */
function setupPCControls() {
    // –ö–ª–∞–≤–∏—à–∏ –¥–≤–∏–∂–µ–Ω–∏—è
    document.addEventListener('keydown', (e) => {
        if (!gameStarted || chatVisible) return;
        
        switch(e.key.toLowerCase()) {
            case 'w': moveForward = true; break;
            case 's': moveBackward = true; break;
            case 'a': moveLeft = true; break;
            case 'd': moveRight = true; break;
            case ' ': jump(); break;
            case 'enter':
                if (!chatVisible) {
                    toggleChat();
                    e.preventDefault();
                }
                break;
        }
    });
    
    document.addEventListener('keyup', (e) => {
        if (!gameStarted) return;
        
        switch(e.key.toLowerCase()) {
            case 'w': moveForward = false; break;
            case 's': moveBackward = false; break;
            case 'a': moveLeft = false; break;
            case 'd': moveRight = false; break;
        }
    });
    
    // –°—Ç—Ä–µ–ª—å–±–∞ –ø–æ –õ–ö–ú
    document.addEventListener('mousedown', (e) => {
        if (!gameStarted || chatVisible || e.button !== 0) return;
        shoot();
    });
    
    // –ê–≤—Ç–æ—Å—Ç—Ä–µ–ª—å–±–∞ –ø—Ä–∏ –∑–∞–∂–∞—Ç–∏–∏
    document.addEventListener('mousemove', handleMouseMove);
}

function handleMouseMove(e) {
    if (!gameStarted || chatVisible) return;
    
    player.rotation.yaw -= e.movementX * mouseSensitivity;
    player.rotation.pitch -= e.movementY * mouseSensitivity * 0.5;
    player.rotation.pitch = Math.max(-Math.PI/2.5, Math.min(Math.PI/2.5, player.rotation.pitch));
}

/* ================= –£–ü–†–ê–í–õ–ï–ù–ò–ï –î–õ–Ø –ú–û–ë–ò–õ–¨–ù–´–• ================= */
function setupMobileControls() {
    const joystick = document.getElementById('moveJoystick');
    const joystickInner = document.getElementById('moveJoystickInner');
    const shootBtn = document.getElementById('shootBtn');
    const jumpBtn = document.getElementById('jumpBtn');

    // –î–∂–æ–π—Å—Ç–∏–∫ –¥–≤–∏–∂–µ–Ω–∏—è
    joystick.addEventListener('touchstart', handleJoystickStart);
    joystick.addEventListener('touchmove', handleJoystickMove);
    joystick.addEventListener('touchend', handleJoystickEnd);

    // –ö–Ω–æ–ø–∫–∞ —Å—Ç—Ä–µ–ª—å–±—ã
    shootBtn.addEventListener('touchstart', (e) => {
        e.preventDefault();
        isShooting = true;
        shoot();
    });
    
    shootBtn.addEventListener('touchend', (e) => {
        e.preventDefault();
        isShooting = false;
    });

    // –ö–Ω–æ–ø–∫–∞ –ø—Ä—ã–∂–∫–∞
    jumpBtn.addEventListener('touchstart', (e) => {
        e.preventDefault();
        jump();
    });

    // –ü–æ–≤–æ—Ä–æ—Ç –∫–∞–º–µ—Ä—ã
    document.addEventListener('touchstart', handleCameraStart);
    document.addEventListener('touchmove', handleCameraMove);
    document.addEventListener('touchend', handleCameraEnd);

    // –ê–≤—Ç–æ—Å—Ç—Ä–µ–ª—å–±–∞
    setInterval(() => {
        if (isShooting && gameStarted) {
            shoot();
        }
    }, CONFIG.SHOOT_COOLDOWN);
}

function handleJoystickStart(e) {
    e.preventDefault();
}

function handleJoystickMove(e) {
    e.preventDefault();
    const touch = e.touches[0];
    const rect = e.currentTarget.getBoundingClientRect();
    
    const centerX = rect.left + rect.width / 2;
    const centerY = rect.top + rect.height / 2;
    
    moveX = (touch.clientX - centerX) / (rect.width / 2);
    moveY = (touch.clientY - centerY) / (rect.height / 2);
    
    const length = Math.sqrt(moveX * moveX + moveY * moveY);
    if (length > 1) {
        moveX /= length;
        moveY /= length;
    }
    
    const inner = document.getElementById('moveJoystickInner');
    inner.style.transform = `translate(${moveX * 30}px, ${moveY * 30}px)`;
}

function handleJoystickEnd() {
    moveX = moveY = 0;
    const inner = document.getElementById('moveJoystickInner');
    inner.style.transform = 'translate(0, 0)';
}

function handleCameraStart(e) {
    for (let i = 0; i < e.touches.length; i++) {
        const touch = e.touches[i];
        const target = document.elementFromPoint(touch.clientX, touch.clientY);
        
        if (target.closest('#moveJoystick') || target.closest('#shootBtn') || 
            target.closest('#chatBtn') || target.closest('#chatWindow') ||
            target.closest('#jumpBtn')) {
            continue;
        }
        
        if (!isRotating) {
            isRotating = true;
            touchId = touch.identifier;
            lastTouchX = touch.clientX;
            lastTouchY = touch.clientY;
            break;
        }
    }
}

function handleCameraMove(e) {
    if (!isRotating || !gameStarted) return;
    
    for (let i = 0; i < e.touches.length; i++) {
        const touch = e.touches[i];
        if (touch.identifier === touchId) {
            const deltaX = touch.clientX - lastTouchX;
            const deltaY = touch.clientY - lastTouchY;
            
            player.rotation.yaw -= deltaX * CONFIG.ROTATION_SPEED;
            player.rotation.pitch -= deltaY * CONFIG.ROTATION_SPEED * 0.5;
            player.rotation.pitch = Math.max(-Math.PI/2.5, Math.min(Math.PI/2.5, player.rotation.pitch));
            
            lastTouchX = touch.clientX;
            lastTouchY = touch.clientY;
            e.preventDefault();
            break;
        }
    }
}

function handleCameraEnd(e) {
    for (let i = 0; i < e.changedTouches.length; i++) {
        if (e.changedTouches[i].identifier === touchId) {
            isRotating = false;
            touchId = null;
            break;
        }
    }
}

/* ================= –§–ò–ó–ò–ö–ê –ò –î–í–ò–ñ–ï–ù–ò–ï ================= */
function jump() {
    if (!gameStarted || !isGrounded) return;
    
    velocityY = CONFIG.JUMP_FORCE;
    isGrounded = false;
    isJumping = true;
    
    // –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –Ω–∞ —Å–µ—Ä–≤–µ—Ä
    if (socket && socket.readyState === WebSocket.OPEN) {
        socket.send(JSON.stringify({
            type: 'jump'
        }));
    }
}

function updatePhysics() {
    // –ì—Ä–∞–≤–∏—Ç–∞—Ü–∏—è
    velocityY -= CONFIG.GRAVITY;
    player.position.y += velocityY;
    
    // –ü—Ä–æ–≤–µ—Ä–∫–∞ –∑–µ–º–ª–∏
    if (player.position.y < CONFIG.PLAYER_HEIGHT) {
        player.position.y = CONFIG.PLAYER_HEIGHT;
        velocityY = 0;
        isGrounded = true;
        isJumping = false;
    }
}

function updateMovement() {
    const moveDirection = new THREE.Vector3(0, 0, 0);
    
    if (isPC) {
        // –î–≤–∏–∂–µ–Ω–∏–µ –¥–ª—è –ü–ö
        const forward = new THREE.Vector3(0, 0, -1);
        forward.applyAxisAngle(new THREE.Vector3(0, 1, 0), player.rotation.yaw);
        
        const right = new THREE.Vector3(1, 0, 0);
        right.applyAxisAngle(new THREE.Vector3(0, 1, 0), player.rotation.yaw);
        
        if (moveForward) moveDirection.add(forward);
        if (moveBackward) moveDirection.add(forward.clone().multiplyScalar(-1));
        if (moveLeft) moveDirection.add(right.clone().multiplyScalar(-1));
        if (moveRight) moveDirection.add(right);
    } else {
        // –î–≤–∏–∂–µ–Ω–∏–µ –¥–ª—è –º–æ–±–∏–ª—å–Ω—ã—Ö (–ò–°–ü–†–ê–í–õ–ï–ù–ù–û–ï)
        const forward = new THREE.Vector3(0, 0, -1);
        forward.applyAxisAngle(new THREE.Vector3(0, 1, 0), player.rotation.yaw);
        
        const right = new THREE.Vector3(1, 0, 0);
        right.applyAxisAngle(new THREE.Vector3(0, 1, 0), player.rotation.yaw);
        
        // –ü—Ä–∞–≤–∏–ª—å–Ω–æ–µ —Å–º–µ—à–∏–≤–∞–Ω–∏–µ –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–π
        moveDirection.add(forward.clone().multiplyScalar(-moveY));
        moveDirection.add(right.clone().multiplyScalar(moveX));
    }
    
    // –ù–æ—Ä–º–∞–ª–∏–∑–∞—Ü–∏—è –∏ –ø—Ä–∏–º–µ–Ω–µ–Ω–∏–µ —Å–∫–æ—Ä–æ—Å—Ç–∏
    if (moveDirection.length() > 0) {
        moveDirection.normalize().multiplyScalar(CONFIG.MOVE_SPEED);
        
        const newPos = player.position.clone().add(moveDirection);
        if (!checkCollision(newPos)) {
            player.position.copy(newPos);
        }
    }
}

/* ================= –ß–ê–¢ ================= */
function toggleChat() {
    const chatWindow = document.getElementById('chatWindow');
    chatVisible = !chatVisible;
    chatWindow.style.display = chatVisible ? 'flex' : 'none';
    
    if (chatVisible) {
        document.getElementById('chatInput').focus();
    } else {
        document.getElementById('chatInput').blur();
    }
}

function handleChatKeyPress(e) {
    if (e.key === 'Enter') {
        sendChatMessage();
    }
}

function sendChatMessage() {
    const input = document.getElementById('chatInput');
    const message = input.value.trim();
    
    if (message && socket && socket.readyState === WebSocket.OPEN) {
        socket.send(JSON.stringify({
            type: 'chat',
            message: message.substring(0, 100)
        }));
        
        addChatMessage(`–í—ã: ${message}`, 'player');
        input.value = '';
        toggleChat(); // –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –∑–∞–∫—Ä—ã–≤–∞–µ–º —á–∞—Ç –ø–æ—Å–ª–µ –æ—Ç–ø—Ä–∞–≤–∫–∏
    }
}

function addChatMessage(text, type = 'normal') {
    const chatMessagesDiv = document.getElementById('chatMessages');
    const messageDiv = document.createElement('div');
    messageDiv.className = type;
    messageDiv.textContent = text;
    
    chatMessagesDiv.appendChild(messageDiv);
    chatMessagesDiv.scrollTop = chatMessagesDiv.scrollHeight;
    
    chatMessages.push({text, type});
    if (chatMessages.length > 50) {
        chatMessages.shift();
    }
}

/* ================= –ó–ê–ü–£–°–ö –ò–ì–†–´ ================= */
function startGame() {
    document.getElementById('menu').classList.add('hidden');
    document.getElementById('ui').classList.remove('hidden');
    document.getElementById('crosshair').classList.remove('hidden');
    
    detectPlatform();
    initGame();
    connectToServer();
}

/* ================= –ü–û–î–ö–õ–Æ–ß–ï–ù–ò–ï –ö –°–ï–†–í–ï–†–£ ================= */
function connectToServer() {
    showNotification('üîÑ –ü–æ–¥–∫–ª—é—á–µ–Ω–∏–µ –∫ —Å–µ—Ä–≤–µ—Ä—É...');
    
    try {
        socket = new WebSocket(CONFIG.SERVER_URL);
        
        socket.onopen = () => {
            showNotification('‚úÖ –ü–æ–¥–∫–ª—é—á–µ–Ω–æ –∫ —Å–µ—Ä–≤–µ—Ä—É!');
            console.log('WebSocket –ø–æ–¥–∫–ª—é—á–µ–Ω');
            gameStarted = true;
            
            socket.send(JSON.stringify({
                type: 'join',
                name: 'Player_' + Math.floor(Math.random() * 1000)
            }));
        };
        
        socket.onmessage = (event) => {
            try {
                const data = JSON.parse(event.data);
                handleServerMessage(data);
            } catch (error) {
                console.error('–û—à–∏–±–∫–∞ –ø–∞—Ä—Å–∏–Ω–≥–∞:', error);
            }
        };
        
        socket.onerror = (error) => {
            console.error('WebSocket –æ—à–∏–±–∫–∞:', error);
            showNotification('‚ùå –û—à–∏–±–∫–∞ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è');
        };
        
        socket.onclose = () => {
            console.log('WebSocket –æ—Ç–∫–ª—é—á–µ–Ω');
            showNotification('üîå –û—Ç–∫–ª—é—á–µ–Ω–æ –æ—Ç —Å–µ—Ä–≤–µ—Ä–∞');
            gameStarted = false;
            
            otherPlayers.forEach(otherPlayer => {
                scene.remove(otherPlayer.mesh);
            });
            otherPlayers.clear();
            updatePlayersCount();
        };
        
    } catch (error) {
        console.error('–û—à–∏–±–∫–∞ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è:', error);
        showNotification('‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–¥–∫–ª—é—á–∏—Ç—å—Å—è');
    }
}

function handleServerMessage(data) {
    switch (data.type) {
        case 'welcome':
            player.id = data.id;
            player.name = data.name || player.name;
            player.color = data.color || 0xff0000;
            player.health = data.health || CONFIG.MAX_HEALTH;
            updateHealth();
            
            if (data.players) {
                data.players.forEach(p => {
                    addOtherPlayer(p.id, p.position, p.rotation, p.health, p.color, p.name);
                });
            }
            
            addChatMessage('‚úÖ –ü–æ–¥–∫–ª—é—á–µ–Ω–æ –∫ —Å–µ—Ä–≤–µ—Ä—É!', 'system');
            break;
            
        case 'player_join':
            if (data.player && data.player.id !== player.id) {
                addOtherPlayer(data.player.id, data.player.position, data.player.rotation, 
                              data.player.health, data.player.color, data.player.name);
                addChatMessage(`üë§ ${data.player.name} –ø—Ä–∏—Å–æ–µ–¥–∏–Ω–∏–ª—Å—è`, 'system');
            }
            break;
            
        case 'player_leave':
            if (otherPlayers.has(data.id)) {
                const playerName = otherPlayers.get(data.id)?.name;
                removeOtherPlayer(data.id);
                if (playerName) {
                    addChatMessage(`üëã ${playerName} –≤—ã—à–µ–ª`, 'system');
                }
            }
            break;
            
        case 'player_update':
            if (data.id !== player.id) {
                updateOtherPlayer(data.id, data.position, data.rotation, data.health);
            }
            break;
            
        case 'player_hit':
            if (data.target === player.id) {
                player.health = Math.max(0, data.health);
                updateHealth();
                
                const hitEffect = document.createElement('div');
                hitEffect.className = 'hit-effect';
                document.body.appendChild(hitEffect);
                setTimeout(() => hitEffect.remove(), 200);
                
                if (player.health <= 0) {
                    showNotification('üíÄ –í—ã –ø–æ–≥–∏–±–ª–∏! –†–µ—Å–ø–∞–≤–Ω —á–µ—Ä–µ–∑ 3 —Å–µ–∫—É–Ω–¥—ã...');
                }
            } else if (otherPlayers.has(data.target)) {
                const otherPlayer = otherPlayers.get(data.target);
                otherPlayer.health = data.health;
            }
            break;
            
        case 'kill':
            kills++;
            updateKills();
            showNotification('üéâ –í—ã —É–±–∏–ª–∏ –∏–≥—Ä–æ–∫–∞! +1 —É–±–∏–π—Å—Ç–≤–æ');
            addChatMessage(`üéØ –í—ã —É–±–∏–ª–∏ ${data.targetName || '–∏–≥—Ä–æ–∫–∞'}`, 'kill');
            break;
            
        case 'death':
            deaths++;
            updateDeaths();
            showNotification(`‚ò†Ô∏è –í–∞—Å —É–±–∏–ª: ${data.killerName || '–∏–≥—Ä–æ–∫'}`);
            addChatMessage(`‚ò†Ô∏è –í–∞—Å —É–±–∏–ª ${data.killerName || '–∏–≥—Ä–æ–∫'}`, 'kill');
            break;
            
        case 'kill_feed':
            if (data.killer && data.victim) {
                addChatMessage(`‚öîÔ∏è ${data.killer} —É–±–∏–ª ${data.victim}`, 'kill');
            }
            break;
            
        case 'chat':
            if (data.player && data.message) {
                addChatMessage(`${data.player}: ${data.message}`);
            }
            break;
            
        case 'respawn':
            if (data.position) {
                player.position.set(data.position.x, data.position.y, data.position.z);
                player.health = data.health || CONFIG.MAX_HEALTH;
                updateHealth();
                showNotification('üîÑ –í—ã –≤–æ–∑—Ä–æ–¥–∏–ª–∏—Å—å!');
            }
            break;
    }
}

/* ================= –°–¢–†–ï–õ–¨–ë–ê –ò –ü–£–õ–ò ================= */
function shoot() {
    if (!socket || socket.readyState !== WebSocket.OPEN || !gameStarted) return;
    
    const now = Date.now();
    if (now - lastShootTime < CONFIG.SHOOT_COOLDOWN) return;
    
    lastShootTime = now;
    
    // –ê–Ω–∏–º–∞—Ü–∏—è –æ—Ç–¥–∞—á–∏ –æ—Ä—É–∂–∏—è
    if (camera.children[0]) {
        camera.children[0].position.z = -0.85;
        camera.children[0].rotation.x = 0.1;
        
        setTimeout(() => {
            if (camera.children[0]) {
                camera.children[0].position.z = -1;
                camera.children[0].rotation.x = 0;
            }
        }, 100);
    }
    
    // –°–æ–∑–¥–∞–µ–º –≤–∏–∑—É–∞–ª—å–Ω—É—é –ø—É–ª—é
    createBullet();
    
    // –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –≤—ã—Å—Ç—Ä–µ–ª –Ω–∞ —Å–µ—Ä–≤–µ—Ä
    socket.send(JSON.stringify({
        type: 'shoot',
        position: {
            x: player.position.x,
            y: player.position.y + 1.5, // –°—Ç—Ä–µ–ª—è–µ–º –∏–∑ —É—Ä–æ–≤–Ω—è –≥–ª–∞–∑
            z: player.position.z
        },
        rotation: player.rotation
    }));
    
    // –ü—Ä–æ–≤–µ—Ä—è–µ–º –ø–æ–ø–∞–¥–∞–Ω–∏–µ
    checkHit();
}

function createBullet() {
    // –°–æ–∑–¥–∞–µ–º –ª—É—á –∏–∑ –∫–∞–º–µ—Ä—ã
    const direction = new THREE.Vector3(0, 0, -1);
    direction.applyEuler(new THREE.Euler(player.rotation.pitch, player.rotation.yaw, 0, 'YXZ'));
    
    const rayOrigin = camera.position.clone();
    const rayDirection = direction.clone().normalize();
    
    // –°–æ–∑–¥–∞–µ–º –ø—É–ª—é –≤ —Å—Ü–µ–Ω–µ
    const bulletGeometry = new THREE.SphereGeometry(0.05, 8, 8);
    const bulletMaterial = new THREE.MeshBasicMaterial({ color: 0xffff00 });
    const bullet = new THREE.Mesh(bulletGeometry, bulletMaterial);
    
    bullet.position.copy(rayOrigin);
    bullet.userData.velocity = rayDirection.multiplyScalar(2); // –°–∫–æ—Ä–æ—Å—Ç—å –ø—É–ª–∏
    bullet.userData.lifeTime = 1000; // –í—Ä–µ–º—è –∂–∏–∑–Ω–∏ 1 —Å–µ–∫—É–Ω–¥–∞
    bullet.userData.createdAt = Date.now();
    
    scene.add(bullet);
    bullets.push(bullet);
    
    // –≠—Ñ—Ñ–µ–∫—Ç –≤—ã—Å—Ç—Ä–µ–ª–∞
    const muzzleFlash = new THREE.PointLight(0xffaa00, 3, 2);
    muzzleFlash.position.set(0, 0, -1.5);
    camera.children[0].add(muzzleFlash);
    setTimeout(() => camera.children[0].remove(muzzleFlash), 50);
}

function updateBullets() {
    const now = Date.now();
    
    for (let i = bullets.length - 1; i >= 0; i--) {
        const bullet = bullets[i];
        
        // –£–¥–∞–ª—è–µ–º —Å—Ç–∞—Ä—ã–µ –ø—É–ª–∏
        if (now - bullet.userData.createdAt > bullet.userData.lifeTime) {
            scene.remove(bullet);
            bullets.splice(i, 1);
            continue;
        }
        
        // –î–≤–∏–≥–∞–µ–º –ø—É–ª—é
        bullet.position.add(bullet.userData.velocity);
        
        // –ü—Ä–æ–≤–µ—Ä—è–µ–º —Å—Ç–æ–ª–∫–Ω–æ–≤–µ–Ω–∏—è —Å–æ —Å—Ç–µ–Ω–∞–º–∏
        for (const wall of walls) {
            const bulletBox = new THREE.Box3().setFromObject(bullet);
            if (bulletBox.intersectsBox(wall)) {
                // –°–æ–∑–¥–∞–µ–º —ç—Ñ—Ñ–µ–∫—Ç –ø–æ–ø–∞–¥–∞–Ω–∏—è –≤ —Å—Ç–µ–Ω—É
                createBulletHole(bullet.position);
                scene.remove(bullet);
                bullets.splice(i, 1);
                break;
            }
        }
    }
}

function createBulletHole(position) {
    // –°–æ–∑–¥–∞–µ–º –≤–∏–∑—É–∞–ª—å–Ω—É—é –º–µ—Ç–∫—É –æ—Ç –ø—É–ª–∏
    const bulletHole = document.createElement('div');
    bulletHole.className = 'bullet-hole';
    bulletHole.style.left = '50%';
    bulletHole.style.top = '50%';
    document.body.appendChild(bulletHole);
    
    setTimeout(() => bulletHole.remove(), 2000);
}

function checkHit() {
    if (!gameStarted || otherPlayers.size === 0) return;
    
    const raycaster = new THREE.Raycaster();
    const direction = new THREE.Vector3(0, 0, -1);
    direction.applyEuler(new THREE.Euler(player.rotation.pitch, player.rotation.yaw, 0, 'YXZ'));
    
    raycaster.set(camera.position, direction);
    
    let closestHit = null;
    let closestDistance = Infinity;
    
    otherPlayers.forEach((otherPlayer, id) => {
        if (!otherPlayer.mesh || !otherPlayer.isAlive) return;
        
        const box = new THREE.Box3().setFromObject(otherPlayer.mesh);
        const intersect = raycaster.intersectBox(box);
        
        if (intersect) {
            const distance = camera.position.distanceTo(otherPlayer.position);
            if (distance < closestDistance && distance < 50) { // –ú–∞–∫—Å–∏–º–∞–ª—å–Ω–∞—è –¥–∞–ª—å–Ω–æ—Å—Ç—å 50 –µ–¥–∏–Ω–∏—Ü
                closestDistance = distance;
                closestHit = { id, otherPlayer };
            }
        }
    });
    
    if (closestHit && socket && socket.readyState === WebSocket.OPEN) {
        socket.send(JSON.stringify({
            type: 'hit',
            target: closestHit.id,
            damage: 34
        }));
        
        showNotification('üí• –ü–æ–ø–∞–¥–∞–Ω–∏–µ!');
        
        // –í–∏–∑—É–∞–ª—å–Ω–∞—è –æ–±—Ä–∞—Ç–Ω–∞—è —Å–≤—è–∑—å
        if (closestHit.otherPlayer.mesh && closestHit.otherPlayer.mesh.children[0]) {
            const originalColor = closestHit.otherPlayer.color;
            closestHit.otherPlayer.mesh.children[0].material.color.setHex(0xff0000);
            setTimeout(() => {
                if (closestHit.otherPlayer.mesh && closestHit.otherPlayer.mesh.children[0]) {
                    closestHit.otherPlayer.mesh.children[0].material.color.setHex(originalColor);
                }
            }, 200);
        }
    }
}

/* ================= –ò–ù–ò–¶–ò–ê–õ–ò–ó–ê–¶–ò–Ø –ò–ì–†–´ ================= */
function initGame() {
    // –°–æ–∑–¥–∞–µ–º —Å—Ü–µ–Ω—É
    scene = new THREE.Scene();
    scene.background = new THREE.Color(0x87CEEB);
    scene.fog = new THREE.FogExp2(0x87CEEB, 0.03);

    // –°–æ–∑–¥–∞–µ–º –∫–∞–º–µ—Ä—É
    camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);

    // –°–æ–∑–¥–∞–µ–º —Ä–µ–Ω–¥–µ—Ä–µ—Ä
    const canvas = document.getElementById('gameCanvas');
    renderer = new THREE.WebGLRenderer({ 
        canvas: canvas, 
        antialias: true,
        alpha: true
    });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    renderer.setPixelRatio(window.devicePixelRatio);

    // –û—Å–≤–µ—â–µ–Ω–∏–µ
    scene.add(new THREE.AmbientLight(0xffffff, 0.5));
    const sun = new THREE.DirectionalLight(0xffffff, 0.9);
    sun.position.set(50, 100, 50);
    sun.castShadow = true;
    sun.shadow.mapSize.width = 2048;
    sun.shadow.mapSize.height = 2048;
    scene.add(sun);

    // –ü–æ–ª
    const floorGeometry = new THREE.PlaneGeometry(200, 200, 50, 50);
    const floorMaterial = new THREE.MeshStandardMaterial({ 
        color: 0x3a5f0b,
        roughness: 0.8,
        metalness: 0.1
    });
    const floor = new THREE.Mesh(floorGeometry, floorMaterial);
    floor.rotation.x = -Math.PI / 2;
    floor.receiveShadow = true;
    scene.add(floor);

    // –°—Ç–µ–Ω—ã
    createWalls();
    
    // –ù–µ–±–æ
    const skyGeometry = new THREE.SphereGeometry(500, 32, 32);
    const skyMaterial = new THREE.MeshBasicMaterial({
        color: 0x87CEEB,
        side: THREE.BackSide
    });
    const sky = new THREE.Mesh(skyGeometry, skyMaterial);
    scene.add(sky);

    // –°–æ–∑–¥–∞–µ–º –ª–æ–∫–∞–ª—å–Ω–æ–≥–æ –∏–≥—Ä–æ–∫–∞
    player = {
        id: '',
        name: '',
        position: new THREE.Vector3(0, CONFIG.PLAYER_HEIGHT, 5),
        rotation: { yaw: 0, pitch: 0 },
        health: CONFIG.MAX_HEALTH,
        color: 0xff0000,
        isMoving: false
    };

    // –û—Ä—É–∂–∏–µ
    createWeapon();

    // –ù–∞—Å—Ç—Ä–∞–∏–≤–∞–µ–º —É–ø—Ä–∞–≤–ª–µ–Ω–∏–µ
    if (isPC) {
        setupPCControls();
    } else {
        setupMobileControls();
    }

    // –ó–∞–ø—É—Å–∫–∞–µ–º –∏–≥—Ä–æ–≤–æ–π —Ü–∏–∫–ª
    gameLoop();

    // –û–±—Ä–∞–±–æ—Ç–∫–∞ –∏–∑–º–µ–Ω–µ–Ω–∏—è —Ä–∞–∑–º–µ—Ä–∞ –æ–∫–Ω–∞
    window.addEventListener('resize', onWindowResize);
}

function createWalls() {
    const wallMaterial = new THREE.MeshStandardMaterial({ 
        color: 0x8a8a8a,
        roughness: 0.6,
        metalness: 0.1
    });

    // –í–Ω–µ—à–Ω–∏–µ —Å—Ç–µ–Ω—ã
    const wallPositions = [
        [0, -40, 80, 6],   // –°–µ–≤–µ—Ä
        [0, 40, 80, 6],    // –Æ–≥
        [-40, 0, 6, 80],   // –ó–∞–ø–∞–¥
        [40, 0, 6, 80]     // –í–æ—Å—Ç–æ–∫
    ];

    wallPositions.forEach(pos => {
        const wall = new THREE.Mesh(
            new THREE.BoxGeometry(pos[2], 6, pos[3]),
            wallMaterial
        );
        wall.position.set(pos[0], 3, pos[1]);
        wall.castShadow = true;
        wall.receiveShadow = true;
        scene.add(wall);
        walls.push(new THREE.Box3().setFromObject(wall));
    });

    // –ü—Ä–µ–ø—è—Ç—Å—Ç–≤–∏—è
    const obstacles = [
        [-15, -15, 4, 4, 4],
        [15, -15, 4, 4, 4],
        [-15, 15, 4, 4, 4],
        [15, 15, 4, 4, 4],
        [0, 0, 8, 4, 8]
    ];

    obstacles.forEach(obs => {
        const obstacle = new THREE.Mesh(
            new THREE.BoxGeometry(obs[2], obs[3], obs[4]),
            new THREE.MeshStandardMaterial({ color: 0x555555, roughness: 0.7 })
        );
        obstacle.position.set(obs[0], obs[3]/2, obs[1]);
        obstacle.castShadow = true;
        obstacle.receiveShadow = true;
        scene.add(obstacle);
        walls.push(new THREE.Box3().setFromObject(obstacle));
    });
}

function createWeapon() {
    const gunGroup = new THREE.Group();
    
    const barrel = new THREE.Mesh(
        new THREE.CylinderGeometry(0.05, 0.05, 0.8, 8),
        new THREE.MeshStandardMaterial({ color: 0x111111, roughness: 0.5, metalness: 0.8 })
    );
    barrel.rotation.x = Math.PI / 2;
    
    const body = new THREE.Mesh(
        new THREE.BoxGeometry(0.25, 0.15, 0.9),
        new THREE.MeshStandardMaterial({ color: 0x222222, roughness: 0.6, metalness: 0.5 })
    );
    
    const handle = new THREE.Mesh(
        new THREE.BoxGeometry(0.15, 0.3, 0.2),
        new THREE.MeshStandardMaterial({ color: 0x333333, roughness: 0.8 })
    );
    handle.position.y = -0.2;
    handle.position.z = -0.1;
    
    gunGroup.add(barrel, body, handle);
    gunGroup.position.set(0.4, -0.3, -1);
    
    camera.add(gunGroup);
}

/* ================= –ò–ì–†–û–í–ê–Ø –õ–û–ì–ò–ö–ê ================= */
function addOtherPlayer(id, position, rotation, health = 100, color = 0x0000ff, name = 'Player') {
    if (otherPlayers.has(id) || id === player.id) return;
    
    const mesh = createPlayerMesh(color);
    mesh.position.set(position.x, position.y || CONFIG.PLAYER_HEIGHT, position.z);
    mesh.rotation.y = rotation.yaw || 0;
    scene.add(mesh);
    
    otherPlayers.set(id, {
        mesh,
        position: new THREE.Vector3(position.x, position.y || CONFIG.PLAYER_HEIGHT, position.z),
        rotation: rotation || { yaw: 0, pitch: 0 },
        health: health,
        name: name,
        color: color,
        isAlive: health > 0
    });
    
    updatePlayersCount();
}

function removeOtherPlayer(id) {
    if (otherPlayers.has(id)) {
        scene.remove(otherPlayers.get(id).mesh);
        otherPlayers.delete(id);
        updatePlayersCount();
    }
}

function updateOtherPlayer(id, position, rotation, health) {
    if (otherPlayers.has(id)) {
        const otherPlayer = otherPlayers.get(id);
        otherPlayer.position.set(position.x, position.y || CONFIG.PLAYER_HEIGHT, position.z);
        otherPlayer.rotation = rotation || otherPlayer.rotation;
        otherPlayer.health = health;
        otherPlayer.isAlive = health > 0;
    }
}

function createPlayerMesh(color) {
    const group = new THREE.Group();

    const bodyGeometry = new THREE.CylinderGeometry(0.3, 0.3, 1.2, 8);
    const bodyMaterial = new THREE.MeshStandardMaterial({ 
        color: color,
        roughness: 0.7,
        metalness: 0.1
    });
    const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
    body.position.y = 0.6;
    body.castShadow = true;

    const headGeometry = new THREE.SphereGeometry(0.25, 8, 8);
    const headMaterial = new THREE.MeshStandardMaterial({ 
        color: 0xf0f0f0,
        roughness: 0.5
    });
    const head = new THREE.Mesh(headGeometry, headMaterial);
    head.position.y = 1.5;
    head.castShadow = true;

    group.add(body, head);
    return group;
}

function checkCollision(position) {
    const playerBox = new THREE.Box3(
        new THREE.Vector3(position.x - CONFIG.PLAYER_RADIUS, 0.5, position.z - CONFIG.PLAYER_RADIUS),
        new THREE.Vector3(position.x + CONFIG.PLAYER_RADIUS, 2.5, position.z + CONFIG.PLAYER_RADIUS)
    );
    
    for (const wall of walls) {
        if (playerBox.intersectsBox(wall)) {
            return true;
        }
    }
    
    return false;
}

/* ================= –ò–ù–¢–ï–†–§–ï–ô–° ================= */
function updateHealth() {
    const healthPercent = (player.health / CONFIG.MAX_HEALTH) * 100;
    document.getElementById('healthText').textContent = player.health;
    document.getElementById('healthFill').style.width = healthPercent + '%';
}

function updatePlayersCount() {
    document.getElementById('playersText').textContent = otherPlayers.size + 1;
}

function updateKills() {
    document.getElementById('killsText').textContent = kills;
}

function updateDeaths() {
    document.getElementById('deathsText').textContent = deaths;
}

function showNotification(text) {
    const notification = document.getElementById('notification');
    notification.textContent = text;
    notification.classList.remove('hidden');
    
    setTimeout(() => {
        notification.classList.add('hidden');
    }, 3000);
}

/* ================= –ì–õ–ê–í–ù–´–ô –¶–ò–ö–õ ================= */
let lastFrameTime = performance.now();

function gameLoop() {
    requestAnimationFrame(gameLoop);
    
    if (!player || !gameStarted) return;
    
    const currentTime = performance.now();
    const deltaTime = Math.min((currentTime - lastFrameTime) / 1000, 0.1);
    lastFrameTime = currentTime;
    
    // –û–±–Ω–æ–≤–ª—è–µ–º —Ñ–∏–∑–∏–∫—É
    updatePhysics();
    
    // –û–±–Ω–æ–≤–ª—è–µ–º –¥–≤–∏–∂–µ–Ω–∏–µ
    updateMovement();
    
    // –û–±–Ω–æ–≤–ª—è–µ–º –∫–∞–º–µ—Ä—É
    camera.position.copy(player.position);
    camera.rotation.order = 'YXZ';
    camera.rotation.y = player.rotation.yaw;
    camera.rotation.x = player.rotation.pitch;
    
    // –û–±–Ω–æ–≤–ª—è–µ–º –ø—É–ª–∏
    updateBullets();
    
    // –ò–Ω—Ç–µ—Ä–ø–æ–ª—è—Ü–∏—è –¥—Ä—É–≥–∏—Ö –∏–≥—Ä–æ–∫–æ–≤
    otherPlayers.forEach(otherPlayer => {
        if (otherPlayer.mesh) {
            otherPlayer.mesh.position.lerp(otherPlayer.position, 0.2);
            otherPlayer.mesh.position.y = CONFIG.PLAYER_HEIGHT - 1.2;
            otherPlayer.mesh.rotation.y = otherPlayer.rotation.yaw;
        }
    });
    
    // –ê–Ω–∏–º–∞—Ü–∏—è –æ—Ä—É–∂–∏—è
    if (camera.children[0]) {
        const time = currentTime * 0.01;
        camera.children[0].position.x = 0.4 + Math.sin(time) * 0.01;
        camera.children[0].position.y = -0.3 + Math.cos(time * 2) * 0.005;
        camera.children[0].rotation.z = Math.sin(time * 0.5) * 0.02;
    }
    
    // –û—Ç–ø—Ä–∞–≤–∫–∞ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è –Ω–∞ —Å–µ—Ä–≤–µ—Ä
    if (socket && socket.readyState === WebSocket.OPEN && gameStarted) {
        socket.send(JSON.stringify({
            type: 'update',
            position: {
                x: player.position.x,
                y: player.position.y,
                z: player.position.z
            },
            rotation: player.rotation,
            health: player.health
        }));
    }
    
    // –†–µ–Ω–¥–µ—Ä–∏–Ω–≥
    if (renderer && scene && camera) {
        renderer.render(scene, camera);
    }
}

function onWindowResize() {
    if (!camera || !renderer) return;
    
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
}

/* ================= –ò–ù–ò–¶–ò–ê–õ–ò–ó–ê–¶–ò–Ø ================= */
window.addEventListener('DOMContentLoaded', () => {
    // –ü—Ä–µ–¥–æ—Ç–≤—Ä–∞—â–∞–µ–º —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω–æ–µ –ø–æ–≤–µ–¥–µ–Ω–∏–µ
    document.addEventListener('gesturestart', e => e.preventDefault());
    document.addEventListener('touchmove', e => {
        if (e.scale !== 1) e.preventDefault();
    }, { passive: false });
    
    showNotification('üëÜ –ù–∞–∂–º–∏—Ç–µ "–ù–ê–ß–ê–¢–¨ –ò–ì–†–£"');
});
</script>
</body>
</html>
