<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="UTF-8">
<title>FPS Multiplayer Shooter</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<style>
* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
    -webkit-touch-callout: none;
    -webkit-user-select: none;
    user-select: none;
    -webkit-tap-highlight-color: transparent;
}

body {
    overflow: hidden;
    background: #000;
    font-family: 'Arial', sans-serif;
    touch-action: none;
    position: fixed;
    width: 100%;
    height: 100%;
}

#gameCanvas {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    z-index: 1;
}

/* –î–∂–æ–π—Å—Ç–∏–∫ –¥–≤–∏–∂–µ–Ω–∏—è */
#moveJoystick {
    position: fixed;
    left: 20px;
    bottom: 20px;
    width: 140px;
    height: 140px;
    border-radius: 50%;
    background: rgba(255, 255, 255, 0.1);
    backdrop-filter: blur(10px);
    border: 2px solid rgba(255, 255, 255, 0.2);
    z-index: 100;
    touch-action: none;
}

#moveJoystickInner {
    position: absolute;
    left: 40px;
    top: 40px;
    width: 60px;
    height: 60px;
    border-radius: 50%;
    background: rgba(255, 255, 255, 0.8);
    box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
    transition: transform 0.1s;
}

/* –ö–Ω–æ–ø–∫–∞ —Å—Ç—Ä–µ–ª—å–±—ã */
#shootBtn {
    position: fixed;
    right: 25px;
    bottom: 25px;
    width: 90px;
    height: 90px;
    border-radius: 50%;
    background: radial-gradient(circle at 30% 30%, #ff4444, #cc0000);
    color: white;
    border: none;
    font-size: 32px;
    box-shadow: 0 6px 20px rgba(255, 0, 0, 0.4);
    z-index: 100;
    touch-action: none;
    display: flex;
    align-items: center;
    justify-content: center;
}

/* –ü—Ä–∏—Ü–µ–ª */
#crosshair {
    position: fixed;
    left: 50%;
    top: 50%;
    transform: translate(-50%, -50%);
    width: 24px;
    height: 24px;
    pointer-events: none;
    z-index: 99;
}

#crosshair::before,
#crosshair::after {
    content: '';
    position: absolute;
    background: rgba(255, 255, 255, 0.9);
    box-shadow: 0 0 4px rgba(0, 0, 0, 0.8);
}

#crosshair::before {
    width: 24px;
    height: 4px;
    top: 10px;
    left: 0;
    border-radius: 2px;
}

#crosshair::after {
    width: 4px;
    height: 24px;
    left: 10px;
    top: 0;
    border-radius: 2px;
}

/* –ò–Ω—Ç–µ—Ä—Ñ–µ–π—Å */
#ui {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    padding: 15px;
    background: linear-gradient(to bottom, rgba(0,0,0,0.8), transparent);
    color: white;
    z-index: 100;
    display: flex;
    justify-content: space-between;
    font-size: 16px;
    font-weight: bold;
    text-shadow: 1px 1px 2px black;
}

.health-bar {
    width: 150px;
    height: 20px;
    background: rgba(0, 0, 0, 0.5);
    border: 2px solid #333;
    border-radius: 10px;
    overflow: hidden;
}

#healthFill {
    height: 100%;
    background: linear-gradient(to right, #ff0000, #00ff00);
    width: 100%;
    transition: width 0.3s;
}

/* –ú–µ–Ω—é */
#menu {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0, 0, 0, 0.95);
    z-index: 1000;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    color: white;
    text-align: center;
}

.menu-content {
    max-width: 500px;
    padding: 30px;
    background: rgba(40, 40, 40, 0.9);
    border-radius: 15px;
    box-shadow: 0 10px 40px rgba(0, 100, 255, 0.3);
}

.menu-content h1 {
    color: #4CAF50;
    margin-bottom: 20px;
    font-size: 2.5em;
    text-shadow: 0 0 10px rgba(76, 175, 80, 0.5);
}

.btn {
    background: linear-gradient(to bottom, #2196F3, #1976D2);
    color: white;
    border: none;
    padding: 15px 30px;
    margin: 10px;
    border-radius: 8px;
    font-size: 18px;
    font-weight: bold;
    cursor: pointer;
    transition: all 0.3s;
    min-width: 200px;
    box-shadow: 0 4px 15px rgba(33, 150, 243, 0.3);
}

.btn:hover {
    background: linear-gradient(to bottom, #1976D2, #0D47A1);
    transform: translateY(-2px);
    box-shadow: 0 6px 20px rgba(33, 150, 243, 0.4);
}

.btn-success {
    background: linear-gradient(to bottom, #4CAF50, #388E3C);
    box-shadow: 0 4px 15px rgba(76, 175, 80, 0.3);
}

.btn-success:hover {
    background: linear-gradient(to bottom, #388E3C, #2E7D32);
    box-shadow: 0 6px 20px rgba(76, 175, 80, 0.4);
}

.hidden {
    display: none !important;
}

/* –£–≤–µ–¥–æ–º–ª–µ–Ω–∏—è */
#notification {
    position: fixed;
    bottom: 20px;
    left: 50%;
    transform: translateX(-50%);
    background: rgba(0, 0, 0, 0.8);
    color: white;
    padding: 15px 30px;
    border-radius: 10px;
    z-index: 1000;
    text-align: center;
    animation: slideUp 0.3s;
}

@keyframes slideUp {
    from { transform: translate(-50%, 100px); opacity: 0; }
    to { transform: translate(-50%, 0); opacity: 1; }
}
</style>
</head>
<body>

<!-- –ú–µ–Ω—é -->
<div id="menu">
    <div class="menu-content">
        <h1>üéØ FPS Multiplayer Shooter</h1>
        <p style="margin-bottom: 20px; color: #ccc;">–ü–æ–¥–∫–ª—é—á–µ–Ω–∏–µ –∫ –≤–∞—à–µ–º—É —Å–µ—Ä–≤–µ—Ä—É</p>
        
        <button class="btn btn-success" onclick="startGame()">üéÆ –ù–ê–ß–ê–¢–¨ –ò–ì–†–£</button>
        <p style="margin-top: 20px; color: #aaa; font-size: 14px;">
            –°–µ—Ä–≤–µ—Ä: wss://fps-game-server-raki.onrender.com
        </p>
    </div>
</div>

<!-- –ò–≥—Ä–æ–≤–æ–π –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å -->
<div id="ui" class="hidden">
    <div>
        <span>‚ù§Ô∏è –ó–¥–æ—Ä–æ–≤—å–µ: <span id="healthText">100</span></span>
        <div class="health-bar">
            <div id="healthFill"></div>
        </div>
    </div>
    <div>
        <span>üë• –ò–≥—Ä–æ–∫–æ–≤: <span id="playersText">1</span></span>
        <br>
        <span>üéØ –£–±–∏–π—Å—Ç–≤: <span id="killsText">0</span></span>
    </div>
</div>

<div id="crosshair" class="hidden"></div>
<div id="moveJoystick" class="hidden">
    <div id="moveJoystickInner"></div>
</div>
<button id="shootBtn" class="hidden">üî´</button>

<canvas id="gameCanvas"></canvas>

<!-- –£–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ -->
<div id="notification" class="hidden"></div>

<script src="https://cdn.jsdelivr.net/npm/three@0.155/build/three.min.js"></script>
<script>
/* ================= –ö–û–ù–§–ò–ì–£–†–ê–¶–ò–Ø ================= */
const CONFIG = {
    MOVE_SPEED: 0.12,
    ROTATION_SPEED: 0.003,
    PLAYER_HEIGHT: 1.7,
    PLAYER_RADIUS: 0.4,
    SHOOT_COOLDOWN: 300,
    MAX_HEALTH: 100,
    SERVER_URL: 'wss://fps-game-server-raki.onrender.com' // –í–ê–® –°–ï–†–í–ï–†!
};

/* ================= –ì–õ–û–ë–ê–õ–¨–ù–´–ï –ü–ï–†–ï–ú–ï–ù–ù–´–ï ================= */
let scene, camera, renderer;
let player, otherPlayers = new Map();
let walls = [];
let socket = null;
let gameStarted = false;

// –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ
let moveX = 0, moveY = 0;
let isRotating = false;
let lastTouchX = 0, lastTouchY = 0;
let touchId = null;
let isShooting = false;
let lastShootTime = 0;

// –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞
let kills = 0;
let deaths = 0;

/* ================= –ó–ê–ü–£–°–ö –ò–ì–†–´ ================= */
function startGame() {
    document.getElementById('menu').classList.add('hidden');
    document.getElementById('ui').classList.remove('hidden');
    document.getElementById('crosshair').classList.remove('hidden');
    document.getElementById('moveJoystick').classList.remove('hidden');
    document.getElementById('shootBtn').classList.remove('hidden');
    
    initGame();
    connectToServer();
}

/* ================= –ü–û–î–ö–õ–Æ–ß–ï–ù–ò–ï –ö –°–ï–†–í–ï–†–£ ================= */
function connectToServer() {
    showNotification('üîÑ –ü–æ–¥–∫–ª—é—á–µ–Ω–∏–µ –∫ —Å–µ—Ä–≤–µ—Ä—É...');
    
    try {
        socket = new WebSocket(CONFIG.SERVER_URL);
        
        socket.onopen = () => {
            showNotification('‚úÖ –ü–æ–¥–∫–ª—é—á–µ–Ω–æ –∫ —Å–µ—Ä–≤–µ—Ä—É!');
            console.log('WebSocket –ø–æ–¥–∫–ª—é—á–µ–Ω');
        };
        
        socket.onmessage = (event) => {
            try {
                const data = JSON.parse(event.data);
                handleServerMessage(data);
            } catch (error) {
                console.error('–û—à–∏–±–∫–∞ –ø–∞—Ä—Å–∏–Ω–≥–∞:', error);
            }
        };
        
        socket.onerror = (error) => {
            console.error('WebSocket –æ—à–∏–±–∫–∞:', error);
            showNotification('‚ùå –û—à–∏–±–∫–∞ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è');
        };
        
        socket.onclose = () => {
            console.log('WebSocket –æ—Ç–∫–ª—é—á–µ–Ω');
            showNotification('üîå –û—Ç–∫–ª—é—á–µ–Ω–æ –æ—Ç —Å–µ—Ä–≤–µ—Ä–∞');
            
            // –£–¥–∞–ª—è–µ–º –¥—Ä—É–≥–∏—Ö –∏–≥—Ä–æ–∫–æ–≤
            otherPlayers.forEach(otherPlayer => {
                scene.remove(otherPlayer.mesh);
            });
            otherPlayers.clear();
            updatePlayersCount();
        };
        
    } catch (error) {
        console.error('–û—à–∏–±–∫–∞ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è:', error);
        showNotification('‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–¥–∫–ª—é—á–∏—Ç—å—Å—è');
    }
}

function handleServerMessage(data) {
    switch (data.type) {
        case 'welcome':
            // –ù–∞—Å –ø—Ä–∏–≤–µ—Ç—Å—Ç–≤—É–µ—Ç —Å–µ—Ä–≤–µ—Ä
            player.id = data.id;
            player.name = data.name;
            player.color = data.color;
            player.health = data.health;
            updateHealth();
            
            // –î–æ–±–∞–≤–ª—è–µ–º –¥—Ä—É–≥–∏—Ö –∏–≥—Ä–æ–∫–æ–≤
            if (data.players) {
                data.players.forEach(p => {
                    addOtherPlayer(p.id, p.position, p.rotation, p.health, p.color, p.name);
                });
            }
            break;
            
        case 'player_join':
            if (data.player && data.player.id !== player.id) {
                addOtherPlayer(data.player.id, data.player.position, data.player.rotation, 
                              data.player.health, data.player.color, data.player.name);
            }
            break;
            
        case 'player_leave':
            removeOtherPlayer(data.id);
            break;
            
        case 'player_update':
            if (data.id !== player.id) {
                updateOtherPlayer(data.id, data.position, data.rotation, data.health);
            }
            break;
            
        case 'player_hit':
            if (data.target === player.id) {
                // –ù–∞—Å —É–¥–∞—Ä–∏–ª–∏
                player.health = Math.max(0, data.health);
                updateHealth();
                
                if (player.health <= 0) {
                    showNotification('üíÄ –í—ã –ø–æ–≥–∏–±–ª–∏! –†–µ—Å–ø–∞–≤–Ω...');
                    setTimeout(() => {
                        player.health = CONFIG.MAX_HEALTH;
                        updateHealth();
                    }, 3000);
                }
            } else if (otherPlayers.has(data.target)) {
                // –ö–æ–≥–æ-—Ç–æ —É–¥–∞—Ä–∏–ª–∏
                const otherPlayer = otherPlayers.get(data.target);
                otherPlayer.health = data.health;
            }
            break;
            
        case 'kill':
            // –ú—ã —É–±–∏–ª–∏ –∫–æ–≥–æ-—Ç–æ
            kills++;
            updateKills();
            showNotification('üéâ –í—ã —É–±–∏–ª–∏ –∏–≥—Ä–æ–∫–∞! +1 —É–±–∏–π—Å—Ç–≤–æ');
            break;
            
        case 'death':
            // –ù–∞—Å —É–±–∏–ª–∏
            deaths++;
            showNotification(`‚ò†Ô∏è –í–∞—Å —É–±–∏–ª: ${data.killerName}`);
            break;
            
        case 'player_shoot':
            // –ö—Ç–æ-—Ç–æ —Å—Ç—Ä–µ–ª—è–µ—Ç
            if (otherPlayers.has(data.id)) {
                const otherPlayer = otherPlayers.get(data.id);
                // –ú–æ–∂–Ω–æ –¥–æ–±–∞–≤–∏—Ç—å –≤–∏–∑—É–∞–ª—å–Ω—ã–π —ç—Ñ—Ñ–µ–∫—Ç –≤—ã—Å—Ç—Ä–µ–ª–∞
            }
            break;
    }
}

/* ================= –ò–ù–ò–¶–ò–ê–õ–ò–ó–ê–¶–ò–Ø –ò–ì–†–´ ================= */
function initGame() {
    // –°–æ–∑–¥–∞–µ–º —Å—Ü–µ–Ω—É
    scene = new THREE.Scene();
    scene.background = new THREE.Color(0x87CEEB);
    scene.fog = new THREE.FogExp2(0x87CEEB, 0.05);

    // –°–æ–∑–¥–∞–µ–º –∫–∞–º–µ—Ä—É
    camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);

    // –°–æ–∑–¥–∞–µ–º —Ä–µ–Ω–¥–µ—Ä–µ—Ä
    renderer = new THREE.WebGLRenderer({ 
        canvas: document.getElementById('gameCanvas'), 
        antialias: true 
    });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;

    // –û—Å–≤–µ—â–µ–Ω–∏–µ
    scene.add(new THREE.AmbientLight(0xffffff, 0.3));
    const sun = new THREE.DirectionalLight(0xffffff, 0.7);
    sun.position.set(50, 100, 50);
    sun.castShadow = true;
    scene.add(sun);

    // –ü–æ–ª
    const floor = new THREE.Mesh(
        new THREE.PlaneGeometry(200, 200),
        new THREE.MeshStandardMaterial({ 
            color: 0x3a5f0b,
            roughness: 0.8
        })
    );
    floor.rotation.x = -Math.PI / 2;
    floor.receiveShadow = true;
    scene.add(floor);

    // –°—Ç–µ–Ω—ã
    createWalls();
    
    // –ù–µ–±–æ
    const skyGeometry = new THREE.SphereGeometry(500, 32, 32);
    const skyMaterial = new THREE.MeshBasicMaterial({
        color: 0x87CEEB,
        side: THREE.BackSide
    });
    const sky = new THREE.Mesh(skyGeometry, skyMaterial);
    scene.add(sky);

    // –°–æ–∑–¥–∞–µ–º –ª–æ–∫–∞–ª—å–Ω–æ–≥–æ –∏–≥—Ä–æ–∫–∞
    player = {
        id: '',
        name: '',
        position: new THREE.Vector3(0, CONFIG.PLAYER_HEIGHT, 5),
        rotation: { yaw: 0, pitch: 0 },
        health: CONFIG.MAX_HEALTH,
        color: 0xff0000,
        isMoving: false,
        mesh: null
    };

    // –û—Ä—É–∂–∏–µ
    createWeapon();

    // –ù–∞—Å—Ç—Ä–∞–∏–≤–∞–µ–º —É–ø—Ä–∞–≤–ª–µ–Ω–∏–µ
    setupControls();

    // –ó–∞–ø—É—Å–∫–∞–µ–º –∏–≥—Ä–æ–≤–æ–π —Ü–∏–∫–ª
    gameLoop();

    // –û–±—Ä–∞–±–æ—Ç–∫–∞ –∏–∑–º–µ–Ω–µ–Ω–∏—è —Ä–∞–∑–º–µ—Ä–∞ –æ–∫–Ω–∞
    window.addEventListener('resize', onWindowResize);
}

function createWalls() {
    const wallMaterial = new THREE.MeshStandardMaterial({ 
        color: 0x8a8a8a,
        roughness: 0.6
    });

    // –í–Ω–µ—à–Ω–∏–µ —Å—Ç–µ–Ω—ã
    const wallPositions = [
        [0, -40, 80, 6],   // –°–µ–≤–µ—Ä
        [0, 40, 80, 6],    // –Æ–≥
        [-40, 0, 6, 80],   // –ó–∞–ø–∞–¥
        [40, 0, 6, 80]     // –í–æ—Å—Ç–æ–∫
    ];

    wallPositions.forEach(pos => {
        const wall = new THREE.Mesh(
            new THREE.BoxGeometry(pos[2], 6, pos[3]),
            wallMaterial
        );
        wall.position.set(pos[0], 3, pos[1]);
        wall.castShadow = true;
        wall.receiveShadow = true;
        scene.add(wall);
        walls.push(new THREE.Box3().setFromObject(wall));
    });

    // –ü—Ä–µ–ø—è—Ç—Å—Ç–≤–∏—è
    const obstacles = [
        [-15, -15, 4, 4, 4],
        [15, -15, 4, 4, 4],
        [-15, 15, 4, 4, 4],
        [15, 15, 4, 4, 4],
        [0, 0, 8, 4, 8]
    ];

    obstacles.forEach(obs => {
        const obstacle = new THREE.Mesh(
            new THREE.BoxGeometry(obs[2], obs[3], obs[4]),
            new THREE.MeshStandardMaterial({ color: 0x555555 })
        );
        obstacle.position.set(obs[0], obs[3]/2, obs[1]);
        obstacle.castShadow = true;
        obstacle.receiveShadow = true;
        scene.add(obstacle);
        walls.push(new THREE.Box3().setFromObject(obstacle));
    });
}

function createWeapon() {
    const gunGroup = new THREE.Group();
    
    const barrel = new THREE.Mesh(
        new THREE.CylinderGeometry(0.05, 0.05, 0.8, 8),
        new THREE.MeshStandardMaterial({ color: 0x111111 })
    );
    barrel.rotation.x = Math.PI / 2;
    
    const body = new THREE.Mesh(
        new THREE.BoxGeometry(0.25, 0.15, 0.9),
        new THREE.MeshStandardMaterial({ color: 0x222222 })
    );
    
    const handle = new THREE.Mesh(
        new THREE.BoxGeometry(0.15, 0.3, 0.2),
        new THREE.MeshStandardMaterial({ color: 0x333333 })
    );
    handle.position.y = -0.2;
    handle.position.z = -0.1;
    
    gunGroup.add(barrel, body, handle);
    gunGroup.position.set(0.4, -0.3, -1);
    
    camera.add(gunGroup);
}

/* ================= –£–ü–†–ê–í–õ–ï–ù–ò–ï ================= */
function setupControls() {
    const joystick = document.getElementById('moveJoystick');
    const joystickInner = document.getElementById('moveJoystickInner');
    const shootBtn = document.getElementById('shootBtn');

    // –î–∂–æ–π—Å—Ç–∏–∫ –¥–≤–∏–∂–µ–Ω–∏—è
    joystick.addEventListener('touchstart', handleJoystickStart);
    joystick.addEventListener('touchmove', handleJoystickMove);
    joystick.addEventListener('touchend', handleJoystickEnd);

    // –ö–Ω–æ–ø–∫–∞ —Å—Ç—Ä–µ–ª—å–±—ã
    shootBtn.addEventListener('touchstart', (e) => {
        e.preventDefault();
        isShooting = true;
        shoot();
    });
    
    shootBtn.addEventListener('touchend', (e) => {
        e.preventDefault();
        isShooting = false;
    });

    // –ü–æ–≤–æ—Ä–æ—Ç –∫–∞–º–µ—Ä—ã
    document.addEventListener('touchstart', handleCameraStart);
    document.addEventListener('touchmove', handleCameraMove);
    document.addEventListener('touchend', handleCameraEnd);

    // –ê–≤—Ç–æ—Å—Ç—Ä–µ–ª—å–±–∞
    setInterval(() => {
        if (isShooting && gameStarted) {
            shoot();
        }
    }, CONFIG.SHOOT_COOLDOWN);
}

function handleJoystickStart(e) {
    e.preventDefault();
}

function handleJoystickMove(e) {
    e.preventDefault();
    const touch = e.touches[0];
    const rect = e.currentTarget.getBoundingClientRect();
    
    const centerX = rect.left + rect.width / 2;
    const centerY = rect.top + rect.height / 2;
    
    moveX = (touch.clientX - centerX) / (rect.width / 2);
    moveY = (touch.clientY - centerY) / (rect.height / 2);
    
    const length = Math.sqrt(moveX * moveX + moveY * moveY);
    if (length > 1) {
        moveX /= length;
        moveY /= length;
    }
    
    const inner = document.getElementById('moveJoystickInner');
    inner.style.transform = `translate(${moveX * 30}px, ${moveY * 30}px)`;
    
    player.isMoving = length > 0.1;
}

function handleJoystickEnd() {
    moveX = moveY = 0;
    const inner = document.getElementById('moveJoystickInner');
    inner.style.transform = 'translate(0, 0)';
    player.isMoving = false;
}

function handleCameraStart(e) {
    for (let i = 0; i < e.touches.length; i++) {
        const touch = e.touches[i];
        const target = document.elementFromPoint(touch.clientX, touch.clientY);
        
        if (target.closest('#moveJoystick') || target.closest('#shootBtn')) {
            continue;
        }
        
        if (touch.clientX > window.innerWidth / 2 && !isRotating) {
            isRotating = true;
            touchId = touch.identifier;
            lastTouchX = touch.clientX;
            lastTouchY = touch.clientY;
            break;
        }
    }
}

function handleCameraMove(e) {
    if (!isRotating) return;
    
    for (let i = 0; i < e.touches.length; i++) {
        const touch = e.touches[i];
        if (touch.identifier === touchId) {
            const deltaX = touch.clientX - lastTouchX;
            const deltaY = touch.clientY - lastTouchY;
            
            player.rotation.yaw -= deltaX * CONFIG.ROTATION_SPEED;
            player.rotation.pitch -= deltaY * CONFIG.ROTATION_SPEED * 0.5;
            player.rotation.pitch = Math.max(-Math.PI/2.5, Math.min(Math.PI/2.5, player.rotation.pitch));
            
            lastTouchX = touch.clientX;
            lastTouchY = touch.clientY;
            e.preventDefault();
            break;
        }
    }
}

function handleCameraEnd(e) {
    for (let i = 0; i < e.changedTouches.length; i++) {
        if (e.changedTouches[i].identifier === touchId) {
            isRotating = false;
            touchId = null;
            break;
        }
    }
}

function shoot() {
    if (!socket || socket.readyState !== WebSocket.OPEN) return;
    
    const now = Date.now();
    if (now - lastShootTime < CONFIG.SHOOT_COOLDOWN) return;
    
    lastShootTime = now;
    
    // –ê–Ω–∏–º–∞—Ü–∏—è –æ—Ç–¥–∞—á–∏
    if (camera.children[0]) {
        camera.children[0].position.z = -0.85;
        setTimeout(() => {
            if (camera.children[0]) {
                camera.children[0].position.z = -1;
            }
        }, 100);
    }
    
    // –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –Ω–∞ —Å–µ—Ä–≤–µ—Ä
    socket.send(JSON.stringify({
        type: 'shoot',
        position: player.position,
        rotation: player.rotation
    }));
    
    // –ü—Ä–æ–≤–µ—Ä–∫–∞ –ø–æ–ø–∞–¥–∞–Ω–∏—è
    checkHit();
}

function checkHit() {
    const direction = new THREE.Vector3(0, 0, -1);
    direction.applyEuler(new THREE.Euler(player.rotation.pitch, player.rotation.yaw, 0, 'YXZ'));
    
    const rayOrigin = camera.position.clone();
    const rayDirection = direction.clone().normalize();
    
    let hitPlayer = null;
    let minDistance = Infinity;
    
    otherPlayers.forEach((otherPlayer, id) => {
        const raycaster = new THREE.Raycaster(rayOrigin, rayDirection);
        const box = new THREE.Box3().setFromObject(otherPlayer.mesh);
        const intersect = raycaster.intersectBox(box);
        
        if (intersect) {
            const distance = rayOrigin.distanceTo(otherPlayer.position);
            if (distance < minDistance) {
                minDistance = distance;
                hitPlayer = { id, otherPlayer };
            }
        }
    });
    
    if (hitPlayer && socket && socket.readyState === WebSocket.OPEN) {
        socket.send(JSON.stringify({
            type: 'hit',
            target: hitPlayer.id,
            damage: 34
        }));
        
        showNotification('üí• –ü–æ–ø–∞–¥–∞–Ω–∏–µ!');
    }
}

/* ================= –ò–ì–†–û–í–ê–Ø –õ–û–ì–ò–ö–ê ================= */
function addOtherPlayer(id, position, rotation, health = 100, color = 0x0000ff, name = 'Player') {
    if (otherPlayers.has(id) || id === player.id) return;
    
    const mesh = createPlayerMesh(color);
    mesh.position.set(position.x, position.y, position.z);
    mesh.rotation.y = rotation.yaw;
    scene.add(mesh);
    
    otherPlayers.set(id, {
        mesh,
        position: new THREE.Vector3(position.x, position.y, position.z),
        rotation: rotation,
        health: health,
        name: name,
        color: color
    });
    
    updatePlayersCount();
}

function removeOtherPlayer(id) {
    if (otherPlayers.has(id)) {
        scene.remove(otherPlayers.get(id).mesh);
        otherPlayers.delete(id);
        updatePlayersCount();
    }
}

function updateOtherPlayer(id, position, rotation, health) {
    if (otherPlayers.has(id)) {
        const otherPlayer = otherPlayers.get(id);
        otherPlayer.position.set(position.x, position.y, position.z);
        otherPlayer.rotation = rotation;
        otherPlayer.health = health;
    }
}

function createPlayerMesh(color) {
    const group = new THREE.Group();

    const bodyGeometry = new THREE.CylinderGeometry(0.3, 0.3, 1.2, 8);
    const bodyMaterial = new THREE.MeshStandardMaterial({ color: color });
    const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
    body.position.y = 0.6;
    body.castShadow = true;

    const headGeometry = new THREE.SphereGeometry(0.25, 8, 8);
    const headMaterial = new THREE.MeshStandardMaterial({ color: 0xf0f0f0 });
    const head = new THREE.Mesh(headGeometry, headMaterial);
    head.position.y = 1.5;
    head.castShadow = true;

    group.add(body, head);
    return group;
}

function checkCollision(position) {
    const playerBox = new THREE.Box3(
        new THREE.Vector3(position.x - CONFIG.PLAYER_RADIUS, 0.5, position.z - CONFIG.PLAYER_RADIUS),
        new THREE.Vector3(position.x + CONFIG.PLAYER_RADIUS, 2.5, position.z + CONFIG.PLAYER_RADIUS)
    );
    
    for (const wall of walls) {
        if (playerBox.intersectsBox(wall)) {
            return true;
        }
    }
    
    return false;
}

/* ================= –ò–ù–¢–ï–†–§–ï–ô–° ================= */
function updateHealth() {
    const healthPercent = (player.health / CONFIG.MAX_HEALTH) * 100;
    document.getElementById('healthText').textContent = player.health;
    document.getElementById('healthFill').style.width = healthPercent + '%';
}

function updatePlayersCount() {
    document.getElementById('playersText').textContent = otherPlayers.size + 1;
}

function updateKills() {
    document.getElementById('killsText').textContent = kills;
}

function showNotification(text) {
    const notification = document.getElementById('notification');
    notification.textContent = text;
    notification.classList.remove('hidden');
    
    setTimeout(() => {
        notification.classList.add('hidden');
    }, 3000);
}

/* ================= –ì–õ–ê–í–ù–´–ô –¶–ò–ö–õ ================= */
let lastFrameTime = performance.now();

function gameLoop() {
    requestAnimationFrame(gameLoop);
    
    if (!player) return;
    
    const currentTime = performance.now();
    const deltaTime = Math.min((currentTime - lastFrameTime) / 1000, 0.1);
    lastFrameTime = currentTime;
    
    // –î–≤–∏–∂–µ–Ω–∏–µ –∏–≥—Ä–æ–∫–∞
    const forward = new THREE.Vector3(0, 0, -1);
    forward.applyAxisAngle(new THREE.Vector3(0, 1, 0), player.rotation.yaw);
    
    const right = new THREE.Vector3(1, 0, 0);
    right.applyAxisAngle(new THREE.Vector3(0, 1, 0), player.rotation.yaw);
    
    const moveDirection = new THREE.Vector3();
    moveDirection.addScaledVector(forward, -moveY);
    moveDirection.addScaledVector(right, moveX);
    
    if (moveDirection.length() > 0) {
        moveDirection.normalize().multiplyScalar(CONFIG.MOVE_SPEED);
        
        const newPos = player.position.clone().add(moveDirection);
        if (!checkCollision(newPos)) {
            player.position.copy(newPos);
        }
    }
    
    // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –∫–∞–º–µ—Ä—ã
    camera.position.copy(player.position);
    camera.rotation.order = 'YXZ';
    camera.rotation.y = player.rotation.yaw;
    camera.rotation.x = player.rotation.pitch;
    
    // –ò–Ω—Ç–µ—Ä–ø–æ–ª—è—Ü–∏—è –¥—Ä—É–≥–∏—Ö –∏–≥—Ä–æ–∫–æ–≤
    otherPlayers.forEach(otherPlayer => {
        otherPlayer.mesh.position.lerp(otherPlayer.position, 0.2);
        otherPlayer.mesh.position.y = CONFIG.PLAYER_HEIGHT - 1.2;
        otherPlayer.mesh.rotation.y = otherPlayer.rotation.yaw;
    });
    
    // –ê–Ω–∏–º–∞—Ü–∏—è –æ—Ä—É–∂–∏—è
    if (player.isMoving && camera.children[0]) {
        const time = currentTime * 0.01;
        camera.children[0].position.x = 0.4 + Math.sin(time) * 0.01;
        camera.children[0].position.y = -0.3 + Math.cos(time * 2) * 0.005;
    }
    
    // –û—Ç–ø—Ä–∞–≤–∫–∞ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è –Ω–∞ —Å–µ—Ä–≤–µ—Ä
    if (socket && socket.readyState === WebSocket.OPEN) {
        socket.send(JSON.stringify({
            type: 'update',
            position: player.position,
            rotation: player.rotation,
            health: player.health
        }));
    }
    
    // –†–µ–Ω–¥–µ—Ä–∏–Ω–≥
    if (renderer && scene && camera) {
        renderer.render(scene, camera);
    }
}

function onWindowResize() {
    if (!camera || !renderer) return;
    
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
}

/* ================= –ò–ù–ò–¶–ò–ê–õ–ò–ó–ê–¶–ò–Ø ================= */
window.addEventListener('DOMContentLoaded', () => {
    // –ü—Ä–µ–¥–æ—Ç–≤—Ä–∞—â–∞–µ–º —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω–æ–µ –ø–æ–≤–µ–¥–µ–Ω–∏–µ
    document.addEventListener('gesturestart', e => e.preventDefault());
    document.addEventListener('touchmove', e => {
        if (e.scale !== 1) e.preventDefault();
    }, { passive: false });
    
    // –ü–æ–∫–∞–∑—ã–≤–∞–µ–º –º–µ–Ω—é
    showNotification('üëÜ –ù–∞–∂–º–∏—Ç–µ "–ù–ê–ß–ê–¢–¨ –ò–ì–†–£"');
});
</script>
</body>
</html>
