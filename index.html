<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="UTF-8">
<title>FPS Multiplayer Shooter</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<style>
* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
    -webkit-touch-callout: none;
    -webkit-user-select: none;
    user-select: none;
    -webkit-tap-highlight-color: transparent;
}

body {
    overflow: hidden;
    background: #000;
    font-family: 'Arial', sans-serif;
    touch-action: none;
    position: fixed;
    width: 100%;
    height: 100%;
}

#gameCanvas {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    z-index: 1;
}

/* –î–∂–æ–π—Å—Ç–∏–∫ –¥–ª—è –¥–≤–∏–∂–µ–Ω–∏—è */
#moveJoystick {
    position: fixed;
    left: 20px;
    bottom: 20px;
    width: 140px;
    height: 140px;
    border-radius: 50%;
    background: rgba(255, 255, 255, 0.1);
    backdrop-filter: blur(10px);
    border: 2px solid rgba(255, 255, 255, 0.2);
    z-index: 100;
    touch-action: none;
}

#moveJoystickInner {
    position: absolute;
    left: 40px;
    top: 40px;
    width: 60px;
    height: 60px;
    border-radius: 50%;
    background: rgba(255, 255, 255, 0.8);
    box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
    transition: transform 0.1s;
}

/* –ö–Ω–æ–ø–∫–∞ —Å—Ç—Ä–µ–ª—å–±—ã */
#shootBtn {
    position: fixed;
    right: 25px;
    bottom: 25px;
    width: 90px;
    height: 90px;
    border-radius: 50%;
    background: radial-gradient(circle at 30% 30%, #ff4444, #cc0000);
    color: white;
    border: none;
    font-size: 32px;
    box-shadow: 0 6px 20px rgba(255, 0, 0, 0.4);
    z-index: 100;
    touch-action: none;
    display: flex;
    align-items: center;
    justify-content: center;
}

/* –ü—Ä–∏—Ü–µ–ª */
#crosshair {
    position: fixed;
    left: 50%;
    top: 50%;
    transform: translate(-50%, -50%);
    width: 24px;
    height: 24px;
    pointer-events: none;
    z-index: 99;
}

#crosshair::before,
#crosshair::after {
    content: '';
    position: absolute;
    background: rgba(255, 255, 255, 0.9);
    box-shadow: 0 0 4px rgba(0, 0, 0, 0.8);
}

#crosshair::before {
    width: 24px;
    height: 4px;
    top: 10px;
    left: 0;
    border-radius: 2px;
}

#crosshair::after {
    width: 4px;
    height: 24px;
    left: 10px;
    top: 0;
    border-radius: 2px;
}

/* –ò–Ω—Ç–µ—Ä—Ñ–µ–π—Å */
#ui {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    padding: 15px;
    background: linear-gradient(to bottom, rgba(0,0,0,0.8), transparent);
    color: white;
    z-index: 100;
    display: flex;
    justify-content: space-between;
    font-size: 16px;
    font-weight: bold;
    text-shadow: 1px 1px 2px black;
}

.health-bar {
    width: 150px;
    height: 20px;
    background: rgba(0, 0, 0, 0.5);
    border: 2px solid #333;
    border-radius: 10px;
    overflow: hidden;
}

#healthFill {
    height: 100%;
    background: linear-gradient(to right, #ff0000, #00ff00);
    width: 100%;
    transition: width 0.3s;
}

/* –ú–µ–Ω—é */
#menu {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0, 0, 0, 0.95);
    z-index: 1000;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    color: white;
    text-align: center;
}

.menu-content {
    max-width: 500px;
    padding: 30px;
    background: rgba(40, 40, 40, 0.9);
    border-radius: 15px;
    box-shadow: 0 10px 40px rgba(0, 100, 255, 0.3);
}

.menu-content h1 {
    color: #4CAF50;
    margin-bottom: 20px;
    font-size: 2.5em;
    text-shadow: 0 0 10px rgba(76, 175, 80, 0.5);
}

.menu-content h2 {
    color: #2196F3;
    margin: 20px 0 10px;
}

.controls-list {
    text-align: left;
    margin: 20px 0;
    padding: 0 20px;
}

.controls-list li {
    margin: 10px 0;
    color: #ddd;
}

.btn {
    background: linear-gradient(to bottom, #2196F3, #1976D2);
    color: white;
    border: none;
    padding: 15px 30px;
    margin: 10px;
    border-radius: 8px;
    font-size: 18px;
    font-weight: bold;
    cursor: pointer;
    transition: all 0.3s;
    min-width: 200px;
    box-shadow: 0 4px 15px rgba(33, 150, 243, 0.3);
}

.btn:hover {
    background: linear-gradient(to bottom, #1976D2, #0D47A1);
    transform: translateY(-2px);
    box-shadow: 0 6px 20px rgba(33, 150, 243, 0.4);
}

.btn-success {
    background: linear-gradient(to bottom, #4CAF50, #388E3C);
    box-shadow: 0 4px 15px rgba(76, 175, 80, 0.3);
}

.btn-success:hover {
    background: linear-gradient(to bottom, #388E3C, #2E7D32);
    box-shadow: 0 6px 20px rgba(76, 175, 80, 0.4);
}

.btn-danger {
    background: linear-gradient(to bottom, #f44336, #d32f2f);
    box-shadow: 0 4px 15px rgba(244, 67, 54, 0.3);
}

.btn-danger:hover {
    background: linear-gradient(to bottom, #d32f2f, #b71c1c);
    box-shadow: 0 6px 20px rgba(244, 67, 54, 0.4);
}

.input-group {
    margin: 20px 0;
}

.input-group input {
    width: 100%;
    padding: 15px;
    border: 2px solid #2196F3;
    border-radius: 8px;
    background: rgba(255, 255, 255, 0.1);
    color: white;
    font-size: 16px;
    text-align: center;
}

.input-group input:focus {
    outline: none;
    border-color: #4CAF50;
    box-shadow: 0 0 10px rgba(76, 175, 80, 0.5);
}

.server-list {
    margin: 20px 0;
    max-height: 200px;
    overflow-y: auto;
}

.server-item {
    background: rgba(255, 255, 255, 0.1);
    margin: 5px 0;
    padding: 10px;
    border-radius: 5px;
    cursor: pointer;
    transition: background 0.3s;
}

.server-item:hover {
    background: rgba(255, 255, 255, 0.2);
}

.hidden {
    display: none !important;
}

/* –£–≤–µ–¥–æ–º–ª–µ–Ω–∏—è */
#notification {
    position: fixed;
    bottom: 20px;
    left: 50%;
    transform: translateX(-50%);
    background: rgba(0, 0, 0, 0.8);
    color: white;
    padding: 15px 30px;
    border-radius: 10px;
    z-index: 1000;
    text-align: center;
    animation: slideUp 0.3s;
}

@keyframes slideUp {
    from { transform: translate(-50%, 100px); opacity: 0; }
    to { transform: translate(-50%, 0); opacity: 1; }
}

/* –ö–Ω–æ–ø–∫–∞ –ø–∞—É–∑—ã */
#pauseBtn {
    position: fixed;
    top: 20px;
    right: 20px;
    width: 50px;
    height: 50px;
    border-radius: 50%;
    background: rgba(255, 255, 255, 0.2);
    border: 2px solid rgba(255, 255, 255, 0.3);
    color: white;
    font-size: 24px;
    z-index: 100;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
}
</style>
</head>
<body>

<!-- –ú–µ–Ω—é -->
<div id="menu">
    <div class="menu-content">
        <h1>üéØ FPS Multiplayer</h1>
        
        <div id="mainMenu">
            <button class="btn btn-success" onclick="showScreen('connectScreen')">üïπÔ∏è –ò–≥—Ä–∞—Ç—å –æ–Ω–ª–∞–π–Ω</button>
            <button class="btn" onclick="showScreen('controlsScreen')">üéÆ –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ</button>
            <button class="btn" onclick="showScreen('aboutScreen')">‚ÑπÔ∏è –û–± –∏–≥—Ä–µ</button>
        </div>

        <div id="connectScreen" class="hidden">
            <h2>–ü–æ–¥–∫–ª—é—á–µ–Ω–∏–µ –∫ —Å–µ—Ä–≤–µ—Ä—É</h2>
            <div class="input-group">
                <input type="text" id="serverInput" placeholder="ws://–≤–∞—à-—Å–µ—Ä–≤–µ—Ä:8080" value="wss://fps-multiplayer-server.onrender.com">
                <small style="color: #aaa; display: block; margin-top: 5px;">–î–ª—è —Ç–µ—Å—Ç–∞ –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ –Ω–∞—à –¥–µ–º–æ-—Å–µ—Ä–≤–µ—Ä –≤—ã—à–µ</small>
            </div>
            <button class="btn btn-success" onclick="connectToServer()">–ü–æ–¥–∫–ª—é—á–∏—Ç—å—Å—è</button>
            <button class="btn" onclick="showScreen('mainMenu')">–ù–∞–∑–∞–¥</button>
            
            <div class="server-list" id="serverList">
                <h3>–ü—É–±–ª–∏—á–Ω—ã–µ —Å–µ—Ä–≤–µ—Ä—ã:</h3>
                <div class="server-item" onclick="connectToServer('wss://fps-multiplayer-server.onrender.com')">
                    üü¢ –î–µ–º–æ-—Å–µ—Ä–≤–µ—Ä (–†–µ–∫–æ–º–µ–Ω–¥—É–µ—Ç—Å—è)
                </div>
            </div>
        </div>

        <div id="controlsScreen" class="hidden">
            <h2>–£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ</h2>
            <div class="controls-list">
                <p>‚úÖ <strong>–õ–µ–≤–∞—è —á–∞—Å—Ç—å —ç–∫—Ä–∞–Ω–∞</strong> - –¥–∂–æ–π—Å—Ç–∏–∫ –¥–ª—è –¥–≤–∏–∂–µ–Ω–∏—è</p>
                <p>‚úÖ <strong>–ü—Ä–∞–≤–∞—è —á–∞—Å—Ç—å —ç–∫—Ä–∞–Ω–∞</strong> - –ø–æ–≤–æ—Ä–æ—Ç –∫–∞–º–µ—Ä—ã (—Ç–∞—á + –¥–≤–∏–∂–µ–Ω–∏–µ)</p>
                <p>‚úÖ <strong>–ö—Ä–∞—Å–Ω–∞—è –∫–Ω–æ–ø–∫–∞ —Å–ø—Ä–∞–≤–∞</strong> - —Å—Ç—Ä–µ–ª—å–±–∞</p>
                <p>‚úÖ <strong>–û–¥–Ω–æ–≤—Ä–µ–º–µ–Ω–Ω–æ –º–æ–∂–Ω–æ:</strong> –¥–≤–∏–≥–∞—Ç—å—Å—è, –ø–æ–≤–æ—Ä–∞—á–∏–≤–∞—Ç—å –∫–∞–º–µ—Ä—É –∏ —Å—Ç—Ä–µ–ª—è—Ç—å</p>
                <p>‚úÖ <strong>–¶–µ–ª—å:</strong> –ø–æ—Ä–∞–∂–∞—Ç—å –¥—Ä—É–≥–∏—Ö –∏–≥—Ä–æ–∫–æ–≤, —É–≤–æ—Ä–∞—á–∏–≤–∞—Ç—å—Å—è –æ—Ç –∏—Ö –≤—ã—Å—Ç—Ä–µ–ª–æ–≤</p>
            </div>
            <button class="btn" onclick="showScreen('mainMenu')">–ù–∞–∑–∞–¥</button>
        </div>

        <div id="aboutScreen" class="hidden">
            <h2>–û–± –∏–≥—Ä–µ</h2>
            <p>–ú–æ–±–∏–ª—å–Ω—ã–π —à—É—Ç–µ—Ä –æ—Ç –ø–µ—Ä–≤–æ–≥–æ –ª–∏—Ü–∞ —Å –º—É–ª—å—Ç–∏–ø–ª–µ–µ—Ä–æ–º.</p>
            <p>–ò—Å–ø–æ–ª—å–∑—É–µ—Ç WebGL –¥–ª—è –≥—Ä–∞—Ñ–∏–∫–∏ –∏ WebSocket –¥–ª—è –æ–Ω–ª–∞–π–Ω-–∏–≥—Ä—ã.</p>
            <p>–ò–≥—Ä–∞ –æ–ø—Ç–∏–º–∏–∑–∏—Ä–æ–≤–∞–Ω–∞ –¥–ª—è –º–æ–±–∏–ª—å–Ω—ã—Ö —É—Å—Ç—Ä–æ–π—Å—Ç–≤.</p>
            <button class="btn" onclick="showScreen('mainMenu')">–ù–∞–∑–∞–¥</button>
        </div>

        <div id="gameUI" class="hidden">
            <div id="ui">
                <div>
                    <span>‚ù§Ô∏è –ó–¥–æ—Ä–æ–≤—å–µ: <span id="healthText">100</span></span>
                    <div class="health-bar">
                        <div id="healthFill"></div>
                    </div>
                </div>
                <div>
                    <span>üë• –ò–≥—Ä–æ–∫–æ–≤: <span id="playersText">1</span></span>
                    <br>
                    <span>üéØ –£–±–∏–π—Å—Ç–≤: <span id="killsText">0</span></span>
                </div>
            </div>
            
            <div id="crosshair"></div>
            <div id="moveJoystick">
                <div id="moveJoystickInner"></div>
            </div>
            <button id="shootBtn">üî´</button>
            <button id="pauseBtn" onclick="showMenu()">‚è∏Ô∏è</button>
            
            <canvas id="gameCanvas"></canvas>
        </div>
    </div>
</div>

<!-- –£–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ -->
<div id="notification" class="hidden"></div>

<script src="https://cdn.jsdelivr.net/npm/three@0.155/build/three.min.js"></script>
<script>
/* ================= –ì–õ–û–ë–ê–õ–¨–ù–´–ï –ü–ï–†–ï–ú–ï–ù–ù–´–ï ================= */
let scene, camera, renderer;
let player, otherPlayers = new Map();
let walls = [];
let socket = null;
let gameStarted = false;

// –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞
let kills = 0;
let deaths = 0;

// –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ
let moveX = 0, moveY = 0;
let isRotating = false;
let lastTouchX = 0, lastTouchY = 0;
let touchId = null;
let isShooting = false;
let lastShootTime = 0;

// –ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è
const CONFIG = {
    MOVE_SPEED: 0.12,
    ROTATION_SPEED: 0.003,
    PLAYER_HEIGHT: 1.7,
    PLAYER_RADIUS: 0.4,
    SHOOT_COOLDOWN: 300,
    MAX_HEALTH: 100,
    RESPAWN_TIME: 3000
};

/* ================= –ò–ù–ò–¶–ò–ê–õ–ò–ó–ê–¶–ò–Ø –ò–ì–†–´ ================= */
function initGame() {
    // –°–æ–∑–¥–∞–µ–º —Å—Ü–µ–Ω—É
    scene = new THREE.Scene();
    scene.background = new THREE.Color(0x87CEEB);
    scene.fog = new THREE.FogExp2(0x87CEEB, 0.05);

    // –°–æ–∑–¥–∞–µ–º –∫–∞–º–µ—Ä—É
    camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);

    // –°–æ–∑–¥–∞–µ–º —Ä–µ–Ω–¥–µ—Ä–µ—Ä
    renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('gameCanvas'), antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;

    // –û—Å–≤–µ—â–µ–Ω–∏–µ
    scene.add(new THREE.AmbientLight(0xffffff, 0.3));
    const sun = new THREE.DirectionalLight(0xffffff, 0.7);
    sun.position.set(50, 100, 50);
    sun.castShadow = true;
    scene.add(sun);

    // –°–æ–∑–¥–∞–µ–º –ø–æ–ª
    const floor = new THREE.Mesh(
        new THREE.PlaneGeometry(200, 200, 50, 50),
        new THREE.MeshStandardMaterial({ 
            color: 0x3a5f0b,
            roughness: 0.8
        })
    );
    floor.rotation.x = -Math.PI / 2;
    floor.receiveShadow = true;
    scene.add(floor);

    // –°–æ–∑–¥–∞–µ–º —Å—Ç–µ–Ω—ã –∏ –ø—Ä–µ–ø—è—Ç—Å—Ç–≤–∏—è
    createWalls();
    
    // –°–æ–∑–¥–∞–µ–º –Ω–µ–±–æ
    const skyGeometry = new THREE.SphereGeometry(500, 32, 32);
    const skyMaterial = new THREE.MeshBasicMaterial({
        color: 0x87CEEB,
        side: THREE.BackSide
    });
    const sky = new THREE.Mesh(skyGeometry, skyMaterial);
    scene.add(sky);

    // –°–æ–∑–¥–∞–µ–º –ª–æ–∫–∞–ª—å–Ω–æ–≥–æ –∏–≥—Ä–æ–∫–∞
    player = {
        id: 'player_' + Date.now() + '_' + Math.random().toString(36).substr(2, 5),
        position: new THREE.Vector3(0, CONFIG.PLAYER_HEIGHT, 5),
        rotation: { yaw: 0, pitch: 0 },
        health: CONFIG.MAX_HEALTH,
        isMoving: false,
        mesh: createPlayerMesh(0xff0000) // –ö—Ä–∞—Å–Ω—ã–π —Ü–≤–µ—Ç –¥–ª—è —Å–µ–±—è
    };
    scene.add(player.mesh);

    // –°–æ–∑–¥–∞–µ–º –æ—Ä—É–∂–∏–µ
    createWeapon();

    // –ù–∞—Å—Ç—Ä–∞–∏–≤–∞–µ–º —É–ø—Ä–∞–≤–ª–µ–Ω–∏–µ
    setupControls();

    // –ó–∞–ø—É—Å–∫–∞–µ–º –∏–≥—Ä–æ–≤–æ–π —Ü–∏–∫–ª
    gameLoop();

    // –û–±—Ä–∞–±–æ—Ç–∫–∞ –∏–∑–º–µ–Ω–µ–Ω–∏—è —Ä–∞–∑–º–µ—Ä–∞ –æ–∫–Ω–∞
    window.addEventListener('resize', onWindowResize);
}

/* ================= –°–û–ó–î–ê–ù–ò–ï –°–¢–ï–ù ================= */
function createWalls() {
    const wallMaterial = new THREE.MeshStandardMaterial({ 
        color: 0x8a8a8a,
        roughness: 0.6
    });

    // –í–Ω–µ—à–Ω–∏–µ —Å—Ç–µ–Ω—ã
    const wallPositions = [
        [0, -40, 80, 6],   // –°–µ–≤–µ—Ä
        [0, 40, 80, 6],    // –Æ–≥
        [-40, 0, 6, 80],   // –ó–∞–ø–∞–¥
        [40, 0, 6, 80]     // –í–æ—Å—Ç–æ–∫
    ];

    wallPositions.forEach(pos => {
        const wall = new THREE.Mesh(
            new THREE.BoxGeometry(pos[2], 6, pos[3]),
            wallMaterial
        );
        wall.position.set(pos[0], 3, pos[1]);
        wall.castShadow = true;
        wall.receiveShadow = true;
        scene.add(wall);
        walls.push(new THREE.Box3().setFromObject(wall));
    });

    // –í–Ω—É—Ç—Ä–µ–Ω–Ω–∏–µ –ø—Ä–µ–ø—è—Ç—Å—Ç–≤–∏—è
    const obstacles = [
        [-15, -15, 4, 4, 4],
        [15, -15, 4, 4, 4],
        [-15, 15, 4, 4, 4],
        [15, 15, 4, 4, 4],
        [0, 0, 8, 4, 8]
    ];

    obstacles.forEach(obs => {
        const obstacle = new THREE.Mesh(
            new THREE.BoxGeometry(obs[2], obs[3], obs[4]),
            new THREE.MeshStandardMaterial({ color: 0x555555 })
        );
        obstacle.position.set(obs[0], obs[3]/2, obs[1]);
        obstacle.castShadow = true;
        obstacle.receiveShadow = true;
        scene.add(obstacle);
        walls.push(new THREE.Box3().setFromObject(obstacle));
    });
}

/* ================= –°–û–ó–î–ê–ù–ò–ï –ò–ì–†–û–ö–ê ================= */
function createPlayerMesh(color) {
    const group = new THREE.Group();

    // –¢–µ–ª–æ (—Ü–∏–ª–∏–Ω–¥—Ä)
    const bodyGeometry = new THREE.CylinderGeometry(0.3, 0.3, 1.2, 8);
    const bodyMaterial = new THREE.MeshStandardMaterial({ color: color });
    const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
    body.position.y = 0.6;
    body.castShadow = true;

    // –ì–æ–ª–æ–≤–∞ (—Å—Ñ–µ—Ä–∞)
    const headGeometry = new THREE.SphereGeometry(0.25, 8, 8);
    const headMaterial = new THREE.MeshStandardMaterial({ color: 0xf0f0f0 });
    const head = new THREE.Mesh(headGeometry, headMaterial);
    head.position.y = 1.5;
    head.castShadow = true;

    group.add(body);
    group.add(head);
    
    return group;
}

/* ================= –°–û–ó–î–ê–ù–ò–ï –û–†–£–ñ–ò–Ø ================= */
function createWeapon() {
    const gunGroup = new THREE.Group();
    
    // –°—Ç–≤–æ–ª
    const barrel = new THREE.Mesh(
        new THREE.CylinderGeometry(0.05, 0.05, 0.8, 8),
        new THREE.MeshStandardMaterial({ color: 0x111111 })
    );
    barrel.rotation.x = Math.PI / 2;
    
    // –û—Å–Ω–æ–≤–∞–Ω–∏–µ
    const body = new THREE.Mesh(
        new THREE.BoxGeometry(0.25, 0.15, 0.9),
        new THREE.MeshStandardMaterial({ color: 0x222222 })
    );
    
    // –†—É–∫–æ—è—Ç—å
    const handle = new THREE.Mesh(
        new THREE.BoxGeometry(0.15, 0.3, 0.2),
        new THREE.MeshStandardMaterial({ color: 0x333333 })
    );
    handle.position.y = -0.2;
    handle.position.z = -0.1;
    
    gunGroup.add(barrel);
    gunGroup.add(body);
    gunGroup.add(handle);
    gunGroup.position.set(0.4, -0.3, -1);
    
    camera.add(gunGroup);
}

/* ================= –£–ü–†–ê–í–õ–ï–ù–ò–ï ================= */
function setupControls() {
    const joystick = document.getElementById('moveJoystick');
    const joystickInner = document.getElementById('moveJoystickInner');
    const shootBtn = document.getElementById('shootBtn');

    // –î–∂–æ–π—Å—Ç–∏–∫ –¥–ª—è –¥–≤–∏–∂–µ–Ω–∏—è
    joystick.addEventListener('touchstart', handleJoystickStart);
    joystick.addEventListener('touchmove', handleJoystickMove);
    joystick.addEventListener('touchend', handleJoystickEnd);

    // –ö–Ω–æ–ø–∫–∞ —Å—Ç—Ä–µ–ª—å–±—ã
    shootBtn.addEventListener('touchstart', (e) => {
        e.preventDefault();
        isShooting = true;
        shoot();
    });
    
    shootBtn.addEventListener('touchend', (e) => {
        e.preventDefault();
        isShooting = false;
    });

    // –ü–æ–≤–æ—Ä–æ—Ç –∫–∞–º–µ—Ä—ã (–ø—Ä–∞–≤–∞—è —á–∞—Å—Ç—å —ç–∫—Ä–∞–Ω–∞)
    document.addEventListener('touchstart', handleCameraStart);
    document.addEventListener('touchmove', handleCameraMove);
    document.addEventListener('touchend', handleCameraEnd);

    // –ê–≤—Ç–æ—Å—Ç—Ä–µ–ª—å–±–∞
    setInterval(() => {
        if (isShooting && gameStarted) {
            shoot();
        }
    }, CONFIG.SHOOT_COOLDOWN);
}

function handleJoystickStart(e) {
    e.preventDefault();
}

function handleJoystickMove(e) {
    e.preventDefault();
    const touch = e.touches[0];
    const rect = e.currentTarget.getBoundingClientRect();
    
    const centerX = rect.left + rect.width / 2;
    const centerY = rect.top + rect.height / 2;
    
    moveX = (touch.clientX - centerX) / (rect.width / 2);
    moveY = (touch.clientY - centerY) / (rect.height / 2);
    
    // –û–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–µ –æ–∫—Ä—É–∂–Ω–æ—Å—Ç—å—é
    const length = Math.sqrt(moveX * moveX + moveY * moveY);
    if (length > 1) {
        moveX /= length;
        moveY /= length;
    }
    
    const inner = document.getElementById('moveJoystickInner');
    inner.style.transform = `translate(${moveX * 30}px, ${moveY * 30}px)`;
    
    player.isMoving = length > 0.1;
}

function handleJoystickEnd() {
    moveX = moveY = 0;
    const inner = document.getElementById('moveJoystickInner');
    inner.style.transform = 'translate(0, 0)';
    player.isMoving = false;
}

function handleCameraStart(e) {
    for (let i = 0; i < e.touches.length; i++) {
        const touch = e.touches[i];
        const target = document.elementFromPoint(touch.clientX, touch.clientY);
        
        // –ü—Ä–æ–ø—É—Å–∫–∞–µ–º –¥–∂–æ–π—Å—Ç–∏–∫ –∏ –∫–Ω–æ–ø–∫—É —Å—Ç—Ä–µ–ª—å–±—ã
        if (target.closest('#moveJoystick') || target.closest('#shootBtn')) {
            continue;
        }
        
        // –ü—Ä–∞–≤–∞—è –ø–æ–ª–æ–≤–∏–Ω–∞ —ç–∫—Ä–∞–Ω–∞ –¥–ª—è –ø–æ–≤–æ—Ä–æ—Ç–∞
        if (touch.clientX > window.innerWidth / 2 && !isRotating) {
            isRotating = true;
            touchId = touch.identifier;
            lastTouchX = touch.clientX;
            lastTouchY = touch.clientY;
            break;
        }
    }
}

function handleCameraMove(e) {
    if (!isRotating || !gameStarted) return;
    
    for (let i = 0; i < e.touches.length; i++) {
        const touch = e.touches[i];
        if (touch.identifier === touchId) {
            const deltaX = touch.clientX - lastTouchX;
            const deltaY = touch.clientY - lastTouchY;
            
            player.rotation.yaw -= deltaX * CONFIG.ROTATION_SPEED;
            player.rotation.pitch -= deltaY * CONFIG.ROTATION_SPEED * 0.5;
            player.rotation.pitch = Math.max(-Math.PI/2.5, Math.min(Math.PI/2.5, player.rotation.pitch));
            
            lastTouchX = touch.clientX;
            lastTouchY = touch.clientY;
            e.preventDefault();
            break;
        }
    }
}

function handleCameraEnd(e) {
    for (let i = 0; i < e.changedTouches.length; i++) {
        if (e.changedTouches[i].identifier === touchId) {
            isRotating = false;
            touchId = null;
            break;
        }
    }
}

/* ================= –°–¢–†–ï–õ–¨–ë–ê ================= */
function shoot() {
    if (!gameStarted) return;
    
    const now = Date.now();
    if (now - lastShootTime < CONFIG.SHOOT_COOLDOWN) return;
    
    lastShootTime = now;
    
    // –ê–Ω–∏–º–∞—Ü–∏—è –æ—Ç–¥–∞—á–∏
    camera.children[0].position.z = -0.85;
    setTimeout(() => {
        if (camera.children[0]) {
            camera.children[0].position.z = -1;
        }
    }, 100);
    
    // –ü—Ä–æ–≤–µ—Ä–∫–∞ –ø–æ–ø–∞–¥–∞–Ω–∏—è
    const direction = new THREE.Vector3(0, 0, -1);
    direction.applyEuler(new THREE.Euler(player.rotation.pitch, player.rotation.yaw, 0, 'YXZ'));
    
    const rayOrigin = camera.position.clone();
    const rayDirection = direction.clone().normalize();
    
    let hitPlayer = null;
    let minDistance = Infinity;
    
    // –ü—Ä–æ–≤–µ—Ä—è–µ–º –ø–æ–ø–∞–¥–∞–Ω–∏–µ –≤ –¥—Ä—É–≥–∏—Ö –∏–≥—Ä–æ–∫–æ–≤
    for (const [id, otherPlayer] of otherPlayers) {
        const raycaster = new THREE.Raycaster(rayOrigin, rayDirection);
        const box = new THREE.Box3().setFromObject(otherPlayer.mesh);
        const intersect = raycaster.intersectBox(box);
        
        if (intersect) {
            const distance = rayOrigin.distanceTo(otherPlayer.position);
            if (distance < minDistance) {
                minDistance = distance;
                hitPlayer = { id, otherPlayer };
            }
        }
    }
    
    // –ï—Å–ª–∏ –ø–æ–ø–∞–ª–∏, –æ—Ç–ø—Ä–∞–≤–ª—è–µ–º –Ω–∞ —Å–µ—Ä–≤–µ—Ä
    if (hitPlayer && socket && socket.readyState === WebSocket.OPEN) {
        socket.send(JSON.stringify({
            type: 'hit',
            target: hitPlayer.id,
            damage: 34
        }));
        
        // –í–∏–∑—É–∞–ª—å–Ω—ã–π —ç—Ñ—Ñ–µ–∫—Ç –ø–æ–ø–∞–¥–∞–Ω–∏—è
        showNotification('üí• –ü–æ–ø–∞–¥–∞–Ω–∏–µ!');
    }
    
    // –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —Å–æ–±—ã—Ç–∏–µ –≤—ã—Å—Ç—Ä–µ–ª–∞
    if (socket && socket.readyState === WebSocket.OPEN) {
        socket.send(JSON.stringify({
            type: 'shoot',
            from: player.id
        }));
    }
}

/* ================= –ö–û–õ–õ–ò–ó–ò–ò ================= */
function checkCollision(position) {
    const playerBox = new THREE.Box3(
        new THREE.Vector3(position.x - CONFIG.PLAYER_RADIUS, 0.5, position.z - CONFIG.PLAYER_RADIUS),
        new THREE.Vector3(position.x + CONFIG.PLAYER_RADIUS, 2.5, position.z + CONFIG.PLAYER_RADIUS)
    );
    
    for (const wall of walls) {
        if (playerBox.intersectsBox(wall)) {
            return true;
        }
    }
    
    return false;
}

/* ================= –°–ï–¢–ï–í–û–ï –í–ó–ê–ò–ú–û–î–ï–ô–°–¢–í–ò–ï ================= */
function connectToServer(serverUrl = null) {
    const url = serverUrl || document.getElementById('serverInput').value;
    
    if (!url) {
        showNotification('‚ö†Ô∏è –í–≤–µ–¥–∏—Ç–µ –∞–¥—Ä–µ—Å —Å–µ—Ä–≤–µ—Ä–∞');
        return;
    }
    
    try {
        socket = new WebSocket(url);
        
        socket.onopen = () => {
            showNotification('‚úÖ –ü–æ–¥–∫–ª—é—á–µ–Ω–æ –∫ —Å–µ—Ä–≤–µ—Ä—É');
            
            // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ–º –∏–≥—Ä—É
            if (!gameStarted) {
                initGame();
                gameStarted = true;
            }
            
            // –ü–æ–∫–∞–∑—ã–≤–∞–µ–º –∏–≥—Ä–æ–≤–æ–π –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å
            document.getElementById('mainMenu').classList.add('hidden');
            document.getElementById('connectScreen').classList.add('hidden');
            document.getElementById('gameUI').classList.remove('hidden');
            document.getElementById('menu').style.display = 'none';
            
            // –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ —Å–µ–±–µ
            socket.send(JSON.stringify({
                type: 'join',
                id: player.id,
                position: player.position,
                rotation: player.rotation,
                health: player.health
            }));
        };
        
        socket.onmessage = (event) => {
            try {
                const data = JSON.parse(event.data);
                handleNetworkMessage(data);
            } catch (e) {
                console.error('–û—à–∏–±–∫–∞ –ø–∞—Ä—Å–∏–Ω–≥–∞ —Å–æ–æ–±—â–µ–Ω–∏—è:', e);
            }
        };
        
        socket.onerror = (error) => {
            console.error('WebSocket –æ—à–∏–±–∫–∞:', error);
            showNotification('‚ùå –û—à–∏–±–∫–∞ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è');
        };
        
        socket.onclose = () => {
            console.log('–û—Ç–∫–ª—é—á–µ–Ω–æ –æ—Ç —Å–µ—Ä–≤–µ—Ä–∞');
            showNotification('üîå –û—Ç–∫–ª—é—á–µ–Ω–æ –æ—Ç —Å–µ—Ä–≤–µ—Ä–∞');
            
            // –£–¥–∞–ª—è–µ–º –¥—Ä—É–≥–∏—Ö –∏–≥—Ä–æ–∫–æ–≤
            for (const [id, otherPlayer] of otherPlayers) {
                scene.remove(otherPlayer.mesh);
            }
            otherPlayers.clear();
            updatePlayersCount();
        };
        
    } catch (error) {
        console.error('–û—à–∏–±–∫–∞ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è:', error);
        showNotification('‚ùå –ù–µ–≤–µ—Ä–Ω—ã–π –∞–¥—Ä–µ—Å —Å–µ—Ä–≤–µ—Ä–∞');
    }
}

function handleNetworkMessage(data) {
    switch (data.type) {
        case 'player_join':
            if (data.id !== player.id) {
                addOtherPlayer(data.id, data.position, data.rotation, data.health);
            }
            break;
            
        case 'player_leave':
            removeOtherPlayer(data.id);
            break;
            
        case 'player_update':
            if (data.id !== player.id) {
                updateOtherPlayer(data.id, data.position, data.rotation, data.health);
            }
            break;
            
        case 'player_hit':
            if (data.target === player.id) {
                // –ü–æ–ª—É—á–∏–ª–∏ —É—Ä–æ–Ω
                player.health = Math.max(0, player.health - data.damage);
                updateHealth();
                
                if (player.health <= 0) {
                    deaths++;
                    showNotification('üíÄ –í—ã –ø–æ–≥–∏–±–ª–∏! –†–µ—Å–ø–∞–≤–Ω...');
                    setTimeout(() => {
                        player.health = CONFIG.MAX_HEALTH;
                        player.position.set(0, CONFIG.PLAYER_HEIGHT, 5);
                        updateHealth();
                    }, CONFIG.RESPAWN_TIME);
                }
            } else if (otherPlayers.has(data.target)) {
                // –ö—Ç–æ-—Ç–æ –¥—Ä—É–≥–æ–π –ø–æ–ª—É—á–∏–ª —É—Ä–æ–Ω
                const otherPlayer = otherPlayers.get(data.target);
                otherPlayer.health = data.health;
            }
            break;
            
        case 'player_kill':
            if (data.killer === player.id) {
                kills++;
                updateKills();
                showNotification('üéâ –í—ã —É–±–∏–ª–∏ –∏–≥—Ä–æ–∫–∞!');
            }
            break;
            
        case 'players_list':
            // –°–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∏—Ä—É–µ–º –≤—Å–µ—Ö –∏–≥—Ä–æ–∫–æ–≤
            for (const playerData of data.players) {
                if (playerData.id !== player.id) {
                    addOtherPlayer(playerData.id, playerData.position, playerData.rotation, playerData.health);
                }
            }
            break;
    }
}

function addOtherPlayer(id, position, rotation, health) {
    if (otherPlayers.has(id) || id === player.id) return;
    
    const mesh = createPlayerMesh(0x0000ff); // –°–∏–Ω–∏–π –¥–ª—è –¥—Ä—É–≥–∏—Ö –∏–≥—Ä–æ–∫–æ–≤
    mesh.position.copy(position);
    mesh.rotation.y = rotation.yaw;
    scene.add(mesh);
    
    otherPlayers.set(id, {
        mesh,
        position: position.clone(),
        rotation: rotation,
        health: health
    });
    
    updatePlayersCount();
}

function removeOtherPlayer(id) {
    if (otherPlayers.has(id)) {
        scene.remove(otherPlayers.get(id).mesh);
        otherPlayers.delete(id);
        updatePlayersCount();
    }
}

function updateOtherPlayer(id, position, rotation, health) {
    if (otherPlayers.has(id)) {
        const otherPlayer = otherPlayers.get(id);
        otherPlayer.position.copy(position);
        otherPlayer.rotation = rotation;
        otherPlayer.health = health;
    }
}

/* ================= –ò–ù–¢–ï–†–§–ï–ô–° ================= */
function updateHealth() {
    const healthPercent = (player.health / CONFIG.MAX_HEALTH) * 100;
    document.getElementById('healthText').textContent = player.health;
    document.getElementById('healthFill').style.width = healthPercent + '%';
}

function updatePlayersCount() {
    document.getElementById('playersText').textContent = otherPlayers.size + 1;
}

function updateKills() {
    document.getElementById('killsText').textContent = kills;
}

function showNotification(text) {
    const notification = document.getElementById('notification');
    notification.textContent = text;
    notification.classList.remove('hidden');
    
    setTimeout(() => {
        notification.classList.add('hidden');
    }, 3000);
}

/* ================= –ú–ï–ù–Æ ================= */
function showMenu() {
    document.getElementById('menu').style.display = 'flex';
}

function showScreen(screenId) {
    // –°–∫—Ä—ã–≤–∞–µ–º –≤—Å–µ —ç–∫—Ä–∞–Ω—ã
    document.querySelectorAll('#menu > .menu-content > div').forEach(el => {
        el.classList.add('hidden');
    });
    
    // –ü–æ–∫–∞–∑—ã–≤–∞–µ–º –Ω—É–∂–Ω—ã–π —ç–∫—Ä–∞–Ω
    document.getElementById(screenId).classList.remove('hidden');
}

/* ================= –ì–õ–ê–í–ù–´–ô –¶–ò–ö–õ ================= */
function gameLoop() {
    requestAnimationFrame(gameLoop);
    
    if (!gameStarted || !player) return;
    
    // –î–≤–∏–∂–µ–Ω–∏–µ –∏–≥—Ä–æ–∫–∞
    const forward = new THREE.Vector3(0, 0, -1);
    forward.applyAxisAngle(new THREE.Vector3(0, 1, 0), player.rotation.yaw);
    
    const right = new THREE.Vector3(1, 0, 0);
    right.applyAxisAngle(new THREE.Vector3(0, 1, 0), player.rotation.yaw);
    
    const moveDirection = new THREE.Vector3();
    moveDirection.addScaledVector(forward, -moveY);
    moveDirection.addScaledVector(right, moveX);
    
    if (moveDirection.length() > 0) {
        moveDirection.normalize().multiplyScalar(CONFIG.MOVE_SPEED);
        
        const newPos = player.position.clone().add(moveDirection);
        if (!checkCollision(newPos)) {
            player.position.copy(newPos);
        }
    }
    
    // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –ø–æ–∑–∏—Ü–∏–∏ –∫–∞–º–µ—Ä—ã –∏ –∏–≥—Ä–æ–∫–∞
    camera.position.copy(player.position);
    camera.rotation.order = 'YXZ';
    camera.rotation.y = player.rotation.yaw;
    camera.rotation.x = player.rotation.pitch;
    
    // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –º–µ—à–∞ –∏–≥—Ä–æ–∫–∞
    player.mesh.position.copy(player.position);
    player.mesh.position.y = CONFIG.PLAYER_HEIGHT - 1.2;
    player.mesh.rotation.y = player.rotation.yaw;
    
    // –ò–Ω—Ç–µ—Ä–ø–æ–ª—è—Ü–∏—è –ø–æ–∑–∏—Ü–∏–π –¥—Ä—É–≥–∏—Ö –∏–≥—Ä–æ–∫–æ–≤
    for (const [id, otherPlayer] of otherPlayers) {
        otherPlayer.mesh.position.lerp(otherPlayer.position, 0.2);
        otherPlayer.mesh.position.y = CONFIG.PLAYER_HEIGHT - 1.2;
        otherPlayer.mesh.rotation.y = otherPlayer.rotation.yaw;
    }
    
    // –ê–Ω–∏–º–∞—Ü–∏—è –æ—Ä—É–∂–∏—è –ø—Ä–∏ –¥–≤–∏–∂–µ–Ω–∏–∏
    if (player.isMoving && camera.children[0]) {
        const time = Date.now() * 0.01;
        camera.children[0].position.x = 0.4 + Math.sin(time) * 0.01;
        camera.children[0].position.y = -0.3 + Math.cos(time * 2) * 0.005;
    }
    
    // –û—Ç–ø—Ä–∞–≤–∫–∞ –¥–∞–Ω–Ω—ã—Ö –Ω–∞ —Å–µ—Ä–≤–µ—Ä
    if (socket && socket.readyState === WebSocket.OPEN) {
        socket.send(JSON.stringify({
            type: 'update',
            id: player.id,
            position: player.position,
            rotation: player.rotation,
            health: player.health
        }));
    }
    
    // –†–µ–Ω–¥–µ—Ä–∏–Ω–≥
    if (renderer && scene && camera) {
        renderer.render(scene, camera);
    }
}

/* ================= –û–ë–†–ê–ë–û–¢–ö–ê –ò–ó–ú–ï–ù–ï–ù–ò–Ø –†–ê–ó–ú–ï–†–ê ================= */
function onWindowResize() {
    if (!camera || !renderer) return;
    
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
}

/* ================= –ò–ù–ò–¶–ò–ê–õ–ò–ó–ê–¶–ò–Ø –ü–†–ò –ó–ê–ì–†–£–ó–ö–ï ================= */
window.addEventListener('DOMContentLoaded', () => {
    // –ü–æ–∫–∞–∑—ã–≤–∞–µ–º –≥–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é
    showScreen('mainMenu');
    
    // –ü—Ä–µ–¥–æ—Ç–≤—Ä–∞—â–∞–µ–º —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω–æ–µ –ø–æ–≤–µ–¥–µ–Ω–∏–µ –∂–µ—Å—Ç–æ–≤
    document.addEventListener('gesturestart', e => e.preventDefault());
    document.addEventListener('touchmove', e => {
        if (e.scale !== 1) e.preventDefault();
    }, { passive: false });
    
    // –ü–æ–∫–∞–∑—ã–≤–∞–µ–º —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –æ –≥–æ—Ç–æ–≤–Ω–æ—Å—Ç–∏
    setTimeout(() => {
        showNotification('üëÜ –ù–∞–∂–º–∏—Ç–µ "–ò–≥—Ä–∞—Ç—å –æ–Ω–ª–∞–π–Ω" –¥–ª—è –Ω–∞—á–∞–ª–∞');
    }, 1000);
});
</script>
</body>
          </html>
